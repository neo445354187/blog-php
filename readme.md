# PHP
## 基础知识

1 ip+端口：可以访问
2 配置DNS：把域名翻译地址；
3 操作系统      Web服务器     数据库              语言
 Windows        IIS             SQL Server       Asp(#)
 Linux         Apache           MySQL            php
 Unix          Tomcat           Oracle             jsp

4 PHP配置文件：php.ini
   Apache的配置文件：httpd.conf
   MySQL配置文件：my.ini

5 开始结束符
- 方式一(采用)
`<?php` 为开始符；
?>为结束符；备注：a 结束符后就不要空格或者enter，这样有可能会出错(在单独的PHP文件中)，如果后面后html代码，那么先enter出空隙，再按标准做；
    b 嵌入html中的位置任意，php在服务器端被执行；
    c 如果以<?php 开始，后面整个文件都是php文件，最好就不要用结束符；
 - 方式二：`<script language="php">  <script>`
 - 方式三：`<? ?>`
 - 方式四：`<% %>`
   

6 分号：功能执行语句都要加分号，如 `echo "aaaa";$a=100;`都要加分号；
        结构定义语句不加分号，如if，或者while 不能加分号；

7 注释符   单行注释：  //或者# 
		   多行注释：/* */       备注：多行注释里不能再有多行注释了；
		   文档注释：/**  */    备注：多行注释里不能再有多行注释了,可以用软件提出来作为一个单独文档；
		   注释写在代码上面或者右边；

8 变量 ，php为弱类型语言，不用声明类型；
  a 变量名以$开始；
  b 变量的名称声明时一定要有意义；
  c 不合法的变量名：不能以数字开头，变量名中不能存在运算符和空格，但是php可以用系统关键字作为变量名（因为$）；
  d 变量名称严格区分大小写（驼峰式命名）；

9 简单函数
var_dump()：输出变量类型和值；
isset()：判断空号中变量存不存在，返回布尔值；
unset():清除括号中的变量；
empty()：判断字符串是否为空(例:$d=""或者$d=null或者这个变量不存在，那么为空)，为空返回为true；

10 可变变量：获取一个普通变量值作为可变变量名；
例：
$name="age";
$$name=16;//相当于$age=16;

11 变量的引用，相当于给变量取了个别名；
例：
$a=10;
$b=&$a;
备注：变量$a或者$b其中任何一个变化，另一个的值也要跟着变化；但是用unset()删除其中一个，另一个还在；
一个变量b只能是另外一个变量a的引用，如果变量b又成为变量c 的引用，那么变量b将和变量a解除引用关系，也就是说一个引用名只能引用一个变量（且只有变量才能有引用，如直接数字100，不能引用）；
注意:$a=$b=10;这个是同时声明两个变量，其中一个变化，另一个不会跟随变化；
 
12 php八种原始类型
标量类型：布尔型（boolean），整型（integer），浮点型（float），字符串（string）；
复合类型：数组（array），对象（object）；
特殊类型：资源（Resourse），NULL；
a 布尔型，boolean为false情况：
// boolean    false
// int            0
//float          0.0          0.00   后面可添加0；
//string        ""            "0"
//array         空数组
//NULL         null(包括没有声明的变量)
其余都为true; 
b 0开头为八进制 ，如：077；
   0x开头为十六进制 ，如：0xff；
备注：如果在浏览器中输出会换算为十进制的数字；
整型用32位存储，如果数字大于2e+31后（e大写也行，省略+默认为+），自动转为浮点数（用64位存储）；
备注2：浮点数是个近似数，最好不要判断相等；如：8==8.0，可能会返回false，但是php是返回true；
c 字符串与JavaScript中一样，连转义字符\都一样；条件是在双引号中 \n表示换行，\r表示回车，\t表示tab键；
注意：字符串的单引号和双引号有区别：
       c-a 双引号中可以解析变量（如：echo "this $int is demo"，echo "this{$int}is demo"），而单引号不能解析变量；
      c-b 在双引号中可以使用转义字符，条件是在双引号中 \n表示换行，\r表示回车，\t表示tab键，\\表示转义\，\$转义（用在改变变量），\[0-7] {1,3}  此正则表达式匹配一个用八进制表示的字符，\x[0-9A-Fa-f] {1,2} 此正则表达式匹配一个用十六进制表示的字符；    在单引号中只能转义单引号自己或者转义转义符号自己，如\\；
备注：如果字符串没有涉及双引号才能使用的功能，那么尽量用单引号；
      c-c 用定界符号声明字符串
           c-c-a 使用<<<三个小于号；
           c-c-b 在开始的定界符（自定义的字符串中）一定要左边挨着<<< ，写完定界符一定要直接回车（空格都不能有）
           c-c-c 在结尾的字符串定界中，一定要顶头写，和开始的字符串字符串要一致，加上分号后并直接回车；
           c-c-d 使用''在开始的定界符号中，将声明的该字符串默认支持双引号的功能，改为单引号功能；
例1(默认支持双引号功能)：

    $str = <<<string
           this is a demo.
    string;
例2(支持单引号功能)：
         $str = <<<'string'
       this is a demo.
string;


d   NULL类型：d-a 被赋值为null的变量；d-b 尚未被赋值的变量；d-c 被unset()函数销毁的变量；

f  伪类型：在写函数说明时用；
    mixed：说明一个参数可以接受多种不同的类型；
    number：说明一个参数可以是integer或者float；
    callback：说明参数是用户自定义函数或者方法；

13 A 强制转换
       getType(变量);获取变量类型；
    A-a   setType(变量，类型名称字符串);强制设置变量转为其他变量类型；
例1：
$int=10;
setType($int,"string");将$int类型转为字符串；
    A-b  在变量使用时，前面加上类型符号，进行转换--是在赋值给新变量新类型，原变量类型不变；
例：
$int=10;
$b=(string)$int;
备注：变量$b将是string类型，但$int将不变；
    A-c  intval(变量)，floatval(变量),strval(变量)，分别强制转化为整型，浮点型，字符串型变量赋值给新变量，但是原变量类型不变哦！
备注：如果float类型强制转化为integer类型，是将float类型小数点后去掉，不是四舍五入，如果转化过来超出integer最大值，多的部分也溢出；
    B 自动转化：小类型转化为大类型（大小类型依据存储大小）；小类型：boolean类型和string类型；稍大类型integer类型；大类型为float（即double类型）；小类型之间不能相互转化（即boolean和string不能相互转化，如果这两种类型相加，则先转化为整型，然后再相加），只能转化为integer或者float；
备注："2sdf"转为整型为2；

布尔类型 ：
a 转化为整型，布尔值为true，则转化后值为1，若布尔值为false，则转化后值为0；
b 转化为字符串型，布尔值为true，则转化后值为'1'，若布尔值为false，则转化后值为 ''；
备注：用echo 来输出布尔类型，则页面将其转化为字符串来输出，即true输出1，false输出     （'' 即空）；

字符串类型：
a 转化为整型，字符串开头含有数字或者科学计数法，则转化为该数字，若开头没有数字，则转化为0；例：$str="12e3sdfsdf"，转化后$str=12e3;
b 转化为布尔类型，字符串不为空或者不是"0"，则转化后值为true(甚至'0.0'也为真)，若为空，则为false；

整型；
a 转化为布尔类型：整型原值不为0，则转化后为true，原值为0，则转化后为false；
b 转化为字符串：转化后就是原值加上引号的字符串，包括原值为0；
备注：浮点型跟整型一样，0.00转化为boolean也是false；


14 变量类型的测试函数
a  is_bool():判断是否是布尔型；
b  is_int()、is_integer()或者is_long():判断是否为整型；
c  is_float()、is_double()和is_real():判断是否为浮点型；
d  is_string()：判断是否为字符串
e  is_array():判断是否为数组；
f  is_object()：判断是否为对象；
g  is_resource():判断是否为资源类型；
h  is_null():判断是否为null类型；注意empty()是判断是否为空；
i   is_scalar(): 判断是否为标量;
j   is_numberic():判断是否是任何类型的数字或者说数字字符串；
k  is_callable():判断是否是有效的函数名；

15常量：在整个脚本运行过程中不变的量（直接是全局的），语法：define("常量名",常量值)；例：define("ROOT","localhost");define("integer",100);备注：a 如果常量没有声明，则常量名自动转化字符串（但效率低）；
         b 常量名称前不要加$符号；
         c 常量名称，默认区分大小写，但是习惯全大写；
         d 可以使用define()第三个参数来决定是否这个常量名称区分大小写（true为不区分，false为默认区分）；
         e 常量的值只支持标量数据类型（int，float，boolean以及string）；
         f  常量不能使用unset()清除一个常量；
         g 可以使用defined();判断一个常量是否存在，返回布尔型；例：defined("ROOT");
         h 可以通过函数constant()来读取常量的值，当然直接用常量名就行了；
         i  get_defined_constants(),可以获得已定义的常量列表（即数组，用var_dump(get_defined_constants());）

16 A 预定义常量：预先已经定义好的常量，可以查看PHP手册，如：M_PI；
    B 魔术常量：在不同位置可能有不同的值；
如(大小写都行)：
__LINE__     文件中的当前行号；
__FILE__     文件中的完整路径和文件名，如果用在被包含文件中，则返回被包含的文件名；
__DIR__      文件所在的目录，如果用在被包含文件中，则返回被包含的文件所在的目录；
__FUNCTION__    函数名称；
__CLASS__       类的名称；
__METHOD__       类的方法名；
__NAMESPACE__  当前命名空间的名称（大小写敏感）；

17 运算符
A 算数运算符号   +, -, *,  /,  %, ++,  --  
B 赋值运算符号    = , +=, -=, *=, /+ ,%=，  .=
C 比较运算符号   > , <, ==, >=, <= ,===, != ,!==
D 逻辑运算符号   && , ||,  !，xor（异或，操作符两边一真一假才返回true）；
E  位运算符号      &  ,  | ,  ^ ,  ~,  >>,  <<
F  其他运算符号   ?  : , @ ,    =>  , ->
备注：
a 加号在PHP中没有连接字符串功能；连接符号是  .  ，其两边是字符串或者字符串及其他类型的变量（其他类型就不能直接在它两边，必须是其他类型的变量）；
例：
echo '这个变量的值：'.$a.'<br />';
echo "这个变量的值：{$a}<br />";
echo "这个变量的值：",$a,"<br />";  （这个用逗号隔开是表示echo的三个参数）
备注：这三个输出一样的；

b %求模（求余数）的正负号由被除数的正负号决定；小数求模没有意义，PHP先把小数转化为整型，再求模；
c  分析：
$i++    直接连续的两个运算：$a = $i;$i = $i + 1; 其中：变量$a为这个位置$i++在整个运算中表现的值；
++$i	直接连续的两个运算：$i = $i + 1; $a = $i;
其中：变量$a为这个位置++$i在整个运算中表现的值；

例：$a=5;
$b=$a++ + ++$a;
$b的值为12；


备注：
布尔型不参与++和--运算，例true++结果还是true;
字符串中++和--是
字符串中++和--是操作字符串中最后一位，若最后一个是数字，则数字+1或-1，如果是字母，则对字母进行升序和降序，如果最后一位是空格或者其他符号，则不变；例1："a"++ 结果为"b"；例2："z"++结果为"aa";例3：$a="bz9";$a++;结果为：ca0 ；

d 比较运算符号，返回值是boolean；例：7=="007";返回值为true；
   逻辑运算符号，返回值也是boolean，逻辑运算符不能在同一运算集中出现，如要用()隔开；
例：if ( ($year%4 == 0 && $year%100 != 0) || ($year%400 == 0) ){}
逻辑运算符号具有短路特性：
      逻辑与    条件1&&条件2，条件1不成立，则条件2根本不执行代码；（用位运算&，代码全部执行）
      逻辑或    条件1  ||   条件2，条件1成立，则条件2的代码也不执行；
例1：
$a=0;$b=0;
if($a =3 || $b=3){
   $a++;
   $b++;
    }
   echo $a.",".$b;
   

结果：1,1
解释：首先赋值优先级只比后++高，比 || 低，先运算后面的逻辑运算符，由于3转化为bool型，为true，则后面直接短路，true赋值给$a，但是bool型不参与++运算，则还是true，true用echo输出则为1
例2：
$a=0;$b=0;
if($a =3 && $b=3){
   $a++;
   $b++;
    }
   echo $a.",".$b;
结果：1,4

f 位运算：二进制的运算；
与运算  值1  &  值2    值1和值2二进制中相对应位置都为1才取1，其余都是0；
或运算  值1   |   值2    值1和值2二进制中相对应位置只要一个为1就取1，其余都是0；
异或运算  值1   ^  值2    值1和值2二进制中相对应位置值不同则取1，相同则是0；
按位非运算    ~值1     按值1的二进制取反；
左右移动运算  值1<<2   按二进制全部左移2位（值1*2^2，左移乘以2的左移位数次方，右移则除），前面溢出，后面两位补00；
备注：
f-a   位运算除了字符串与字符串进行位运算，返回结果为字符串外，其他的数据类型进行位运算都返回整型（包括字符串与整型，布尔型与布尔型等进行位运算都是返回整型）；
f-b   & 和 | 可以分别充当逻辑运算符 && 和 ||，但是前者没有短路；

g 其他运算符
g-a  三元运算符：条件 ？ 表达式1 ：表达式2
备注：表达式类型时直接的值或者赋值等式，不能为复杂功能语句（如：true?echo "这就不行":"不行"）
g-b 反引号``   但是反引号里是系统命令；

g-c @ 临时屏蔽错误信息（错误级别不高可以被屏蔽）；例：@echo $a;(了解)

18 
A多条分支
if(条件1){
}else if(条件2){
}else if(条件3){
}····
}else{
}
备注：a 最终的else(){}可以省略，且else if是js中式分开的，在php中既可以是else if也可以是elseif；
b 多路分支只能进入最先满足条件的一个；

B switch(变量){
case 值1:
case 值2:
case 值3:
             语句1;
             break;


case 值4:
             语句3;
             break;
·····
 default：语句；break(可选);
}
备注：switch（）括号必须是变量；default在前面值不匹配时，执行其中代码；
switch-case 注意细节：
a 如果在case中的语句过多，就需要将多个语句做成一个函数之类的；
b switch（变量）中的变量类型 只有两种：整型和字符串；
c break是退出switch结构使用的，如果需要同时匹配多个值时，可以使用多个case而不加break，如上例；流程进入switch后，要么通过break出去，要么从最后出去；
d else if 判断范围时使用（用switch写的也可以用else if 写）；
   switch case  单个值匹配进行分支；

19
php中两个预定义数组:$_POST 和$_GET
语法：$_POST[name]；获取传过来与name相对于value的值（value值包括属性中的value值和标签中间的值）；
语法：$_GET[name]；获取传过来与name相对于value的值（value值包括属性中的value值和标签中间的值）；
备注：
       标签<select></select>是取标签<select></select>的name值，不是标签<option></option>的name值；
       但是设置提交后保留在某个选项，又是在标签<option></option>中操作，如下例：
<option <?php echo $selector=="+" ? "selected='selected'" : "" ;?>>+</option>
<option <?php echo $selector=="-" ? "selected='selected'" : "" ;?>>-</option>

屏蔽注意警告：error_reporting(E_ALL & ~E_NOTICE);

20 php是内嵌html的脚步语言；几乎除了标签字母中不能嵌入以外，其他地方都能嵌入，并且改变html文档，然后html文档被浏览器执行；

21 循环
A while 大量应用于条件循环；
语法：while(条件){循环体}

B do-while
语法：do{循环体}while(条件);     特别注意后面的分号一定要加上；

C for
语法：for(初始条件;判读条件;自增条件)；
例：for($i=0,$j=0;$i<100 || $j>0;$i++,$j--){} 
      echo $i;
   特别注意：在循环外，$i依然存在，如果经过前例那么$i为100；if和循环的{}中声明的变量，后面代码依然可以用，但是函数内部声明变量或者形参，只能在函数内部调用（形参可以传值）；

D goto 利用标志，直接跳到标志位置代码处执行；
   标志的定义,    标志名：{代码}；注意：标志本身并不会阻碍代码执行，且代码外的{}不是必须的；
   语法：goto  标志名；
备注：结束goto循环不用break，而是采用另一个goto跳出循环；

E 特殊循环语句：
  E-a  break 功能：退出for循环，while循环和do-while循环，当然也可以退出switch-case；
备注：语法：break 数字；数字表示退出循环层数；例：break 2; 表示退出二层循环；（实践后可行）

  E-b  continue 功能：跳过for循环，while循环和do-while循环本次循环，进行下一次循环；
备注：语法：continue 数字；数字表示跳过循环次数；例：continue 2; 表示跳过两次循环；（实践后好像不行）
特别注意：
$i=0;
while($i<100){
if($i%3==0) continue;
echo "这个是个死循环！";
$i++;
}

说明：这是一个死循环，因为用continue跳过此次循环后$i不会自增，永远停留在那里，这一点值得注意，计数循环还是用for吧！
  E-c  exit（别名die）    功能：退出脚本；写法：exit 或者exit("这句话输出后，程序结束")；


22 函数：是一段完成指定任务的已命名代码块；  ；种类：自定义函数和系统函数；
备注：
a 调用函数可以在声明该函数之前；
b 形参是声明时括号中的参数，实参是函数调用时括号中的参数；
c 用return 终止函数，写在return后面的代码不会被执行；
d 函数不能重名（包括与系统函数也不能重名，大写A和小写a也算重名）；
e 函数名不区分大小写；
f 用function_exists("函数名")判断函数是否存在，返回boolean； 

23
A  全局变量：在函数外部声明的变量，可以在每个函数中都能使用；
a  PHP规定：所有在函数内部写的变量都是新声明的局部变量；
b  在函数内部如果需要使用函数外部的变量，需要使用global关键字，将外部变量引入，不引入将会报错；
   例1：global $a,$b;
   例2：
         $name="hehe";
 function demo(){
        $name="haha"; //新的局部变量；
        global $name;
        echo $name;     //输出全局变量；
}

c  常量可以直接被函数内部引用；
d  全局数组也可以被函数内部引用，如$_POST["name"];
e  如果函数内部需要调用全局变量，全局变量只要声明在调用函数的代码之前就行，不一定要声明在函数声明之前； 
B 局部变量：函数内部声明的变量；

C 静态变量：用关键字static声明的变量；
a  在函数中（函数外跟全局变量就没区别了，没必要）声明的静态变量，只在第一次调用时声明；
b  第二次以及更多次，要先判断静态区是否已经存储该变量（同一变量名，但是在不同函数中声明，存储是不同的），如果有，将跳过声明，直接引用；
c  静态变量，在同一函数多次调用中共享（记着是同一函数）；
d  生命期：由声明-脚本结束；

24 
A   只有在内存中的变量才有地址；
B   函数形参中有&$变量名，那么调用函数时的实参只能是变量，不能为具体的值，并且函数中该变量自动为实参变量的引用，即如果函数中变量改变，那么函数外的实参变量也要改变；
例：
    $a=10;
    function func(&$b){
  	  $b++;
   	 echo $b;
    }
    func($a);
备注：$a的值也变为了11；总结：a 实参必须是变量 b 建立的引用关系；

C   默认参数：就是给形参的变量赋值；在调用函数时没给实参时，就调用默认参数值；
例：function($age,$name[,$email="445354187@qq.com"[，$neo="liu"]]){}  
备注：$age和$name是必选参数；$email和$neo是分别可选参数；
利用默认参数可以使实参个数小于形参个数；

D   func_get_args();在函数内部接收实参值，返回实参数组；
    func_num_args();在函数内部接收实参个数（返回为int型）；
    func_get_arg(int);在函数内部接收实参数组下标为int的值；
利用上面函数可以使实参个数大于形参个数；
例：
 function demo(){
     $arr = func_get_args();
     echo $arr[0];
}
   demo(1,2,3,4,5,6);
备注：func_get_args()就可以将所有实参赋值给数组$arr;即实参和形参个数之间没有对应关系；

25 变量函数：函数名用变量代替，语法：$变量名();
原理：将函数名赋值给变量，用  $变量名();  来替代函数的调用；
应用：赋不同函数名给变量，变量函数将调用不同函数；
例：
function demo($a,$b){
              echo $a+$b;
     }
$var = "demo";
$var(2,4);


26  print_r(数组) ；打印数组；
    strlen();该函数返回字符串长度；

27 回调函数：在函数调用时，将一个函数（函数名）作为实参进行传递，那么作为实参的函数就是回调函数；
备注：
a  第一种：在调用的函数中，回调函数的函数名是作为实参，变量函数的变量是作为形参（如：变量函数$demo(),那么变量是$demo）；
b  第二种：调用类的方法（也就是函数）或者对象方法时，就不能用变量函数来调用这个函数；而是利用 call_user_func_array()；（采用）
语法一，函数为全局函数：call_user_func_array(函数b的名，传去函数b的参数的数组)；
语法二，函数时类或者对象的方法：call_user_func_array(array(对象或者类名，方法c的名)，传去方法c的参数的数组)；*************

28 
遍历文件夹：
A opendir(路径);路径： .表示当前文件夹，..表示父文件夹，/表示根路径；文件夹名时路径的一部分；
返回路劲中文件夹中所有文件信息，假设赋值给$dir；
B readdir($dir); 一个一个遍历指定文件夹中文件，返回文件名字以及其类型（文件夹只有名字）；是一个readdir($dir)操作一个文件，其中最开始两个为 .   ..  
C closedir（$dir） 关闭打开文件夹；

29 递归函数：在函数中调用自己的函数；分为两个过程：递---归；特殊注意“归”；

30 include 引用其他文件进入php文件，并不是复制文件进入php文件，而是经过了特殊处理;
语法1：include 路劲+文件 ；
语法2：include (路劲+文件) ;（采用）
语法1：include_once 路劲+文件 ；这种能处理重复包含同一个函数库，导致的错误；
语法2：include_once (路劲+文件) ; 这种能处理重复包含同一个函数库，导致的错误；
例：
include "function.inc.php";
include "function.inc.php";
备注：调用一次，将会重新定义一次，那么就像函数重复定义将会产生错误；
include_once "functin.inc.php";
include_once "functin.inc.php";
备注：这个先判断，则不会出错；当然如果是include "hehe.txt";如果hehe.txt内容aaaa<br/>这种，重复包含只是多次输出而已，不会出错，只有重复定义函数时才会出错；
语法1：require 路径+文件；
语法2：require (路径+文件)；（采用）
语法1：require_once 路径+文件；
语法2：require_once (路径+文件)；
备注：include与require功能几乎相同，只是include包含函数失败，会使一个警告，require则是致命错误（程序崩溃），情况：在必须包含一个文件，如果包含失败，脚本就无法执行，那么选择require；情况：根据不同情况包含，则选择include；
例：
require "demo.txt";
例2：
if($a==true) include "hehe.txt";
else include "neo.txt";



32 数组：若干个变量的集合；
分类：
a 索引数组，下标为整数型；例：$arr[0]="aaaa";
b 关联数组：下标为字符串；例：$arr["one"]="bbbb";

声明：
A 
a 直接赋值：$arr[0]="aaaa";或者$arr["one"]="bbbb";（备注：$arr[0]中[]也可以换成{}，但建议[];）
备注：echo "11111$arr['one']1111111"; $arr['one']不是特殊符号，能成功获取到值；
b 关联数组下标一定要使用引号，不要使用常量名称（虽然也会显示，但效率低）；
c 关联数组和索引数组的下标在同一个数组中是可以同时存在的；例： $arr['one']=1;$arr[2]=2;是可以同时存在的；
d key会有如下强制转化：
     包含合法整型值得字符串会被转化为整型。如键值名“8”实际会被储存为8.但是'08'不会强制转化，因为不是一个合法的十进制数值，同时“8asdf“也不会被转化整型，而本身就是字符串，为关联数组；
      浮点数也会转为整型，采用割舍，9.8转化后为9；
      布尔型也转化为整型，true为1，false为0；
      null则转化为空字符串，为$arr[];数组和对象不能为键名；
****索引数组的自动增涨下标，默认是从0开始的，自动增涨的都是出现过（'出现过'意思为上面的代码）的最大值加1；关联数组不会影响索引数组下标的排列规则；
例：
$arr[]=0; //下标0
$arr[]=1;//下标1
$arr[]=2;//下标2
$arr[8]=8;//下标8
$arr[]=9;//下标9
$arr[9]=10;//下标9,覆盖前面那个；
$arr[-100]=-100;是可以的，下标就是﹣100；
$arr[]=10; //下标为10，因为最大值+1；

B 使用array()函数声明数组，默认是索引下标，也可以使用=>符号指定下标,key=>value；
例：$arr=array("aaaa","two"=>"bbbb",9=>"cccc");

C $arr=["aaa","bbb",9=>"ccc"];在php5.4版本后；(采用)

D unset可以删除数组的key=>value;而设置某个键value为null，key不会消失；并且注意：这种方式删除后，不会重新索引；如果要重新索引，则在删除后，用array_values()函数；
例：
unset($arr[1]);
$arr=array_values($arr);

E 二维数组声明，注意元素也不一定非要是数组；
语法1：$group=array(array(),array(),array());
            $group=[[],[],[]];
备注：
$group[][]="";  自动增涨//下标[0][0]
$group[][]="";//下标[1][0]
$group[][]="";//下标[2][0]

F 遍历数组
F-a for循环遍历数组（效率最高），但下标不连续和关联数组就不太实用；
F-b foreach     （采用）
语法1：foreach(数组  as 自定义变量){};
数组有多少个元素，foreach就循环多少遍；
foreach会将数组中的元素在每次循环中，依次将元素的值给自定义变量，并适用于下标不连续或者关联数组等所有类型数组；

语法2：foreach(数组  as 下标变量 => 值变量){}
备注：当然'值变量'也可以是数组（因为有可能是二维及多维数组）；

F-c list() each()和while()协同遍历；不足：如果不用reset()将指针回执，就只能遍历一次；
c-a  list() 函数，但这个函数跟其他函数用法不同；
语法：list() = 数组;
作用：将数组中的元素赋值给变量使用；说明：通常数组中有几个元素，在list()中就有几个参数，而且参数必须是变量（新声明的自定义变量），不能为值，并且只能是索引数组（且下标连续，猜测：list()函数中应该用的是for循环），转为变量；例1：list($a, ,$c)=["a","b","c"];只接收第一个和第三个元素，注意中间空着；
例2：list($a,$b)=["a","b","c"];只接收第一个和第二个元素；

c-b each() 只是一个函数，参数只能是一个数组的变量（不能直接为数组），返回的值也是一个数组；
   返回的数组包括四个固定元素，而且下标也是固定的；下标：1  value  0 key  分别对应参数数组中被操作的元素的：值   值   下标   下标；
   each()只处理当前的元素，将当前的元素（默认为第一个元素）转为数组信息，处理完成后，指针指向下一个元素移动；如果指针已经在结束位置了，如果再使用each()获取元素，则返回false；
例：
$arr=["aaa","bbb","ccc"];
while(list($a,$b)=each($arr)){
	echo $a."=>".$b."<br />";
}
备注：each()返回为四个元素的数组，而在这儿list($a,$b)只能直能接收两个，因为list()只能是索引且下标连续的数组；

G 控制指针函数

next() 参数为数组，负责将指针向后移动；
prev()  参数为数组，负责将指针向前移动；
end()  参数为数组，负责将指针移动到最后；
reset() 参数为数组，负责将指针无条件移至第一个索引位置；
key() 参数为数组，获取当前元素的键；
current() 参数为数组，获取当前元素的值；

33 超全局数组（变量），在php的脚步中，已经声明好的变量，可以直接使用（名字不变）；
$_SERVER       服务器变量，获取服务器的信息；
$_ENV          环境变量（了解）
$_GET          HTTP GET变量，接收用户通过URL向服务器传递的参数
$_POST         HTTP GET变量，接收用户通过http协议向服务器传递的数据
$_REQUEST      request变量    ，不管什么方式传递到服务器的信息都能接收（不建议采用）；
$_FILES	      HTTP文件上传变量
$_COOKIE       HTTP Cookies
$_SESSION      Session变量
$GLOBALS      Global变量   所有已定义全局变量组成的数组（包括预定义和自定义），变量名就是该组的索引（没有$符号）；
备注：
1. 数组（关联数组），就和你自己声明的数组是一样的操作方式；
2. 全局：在函数内部调用，不用添加关键字global；
3.每个预定义数组都有独特的能力；
4.不要用超全局数组作为形参；

34 数组和字符串操作函数都要会；
a     array_values(数组) 返回数组的值（并不改变原来数组）；
b     array_keys(数组 [,值 [,bool]]) 返回数组的键值（并不改变原来数组）；
例：$arr=array_keys($arr,"bbb",true);备注：第三个参数为true，则要求类型和值都要符合；
c      in_array(被查询值，数组 [,bool])      检查数组中是否存在某个值（也可以为数组），返回bool，可选参数为true，则要求被查询值与数组中的值不仅值相同且类型也要相同；
d     array_search(被查询值，数组 [,bool])   在数组中搜索给定的值，如果成功则返回第一个匹配元素的键名；
e     array_key_exists(键值，数组)     检查数组中的键值存不存在，返回bool；
f     isset()         判断变量存不存在，返回bool型，注意数组中某元素空值isset返回为false，但e中函数为true；
g     array_flip(数组) 交换数组中的键和值（类型只能是整型和字符串）；注意：交换后键出现重复，那么后面的值覆盖前面的值；
h     array_reverse(数组 [,bool])   返回将数组中元素倒序组成新的数组；可选参数为true，则保留索引数组键值（即 1=>"bb" 0=>"aa" ）,默认为false不保留，但对于关联数组这个参数每意义；

统计数组元素个数和唯一性
i count(数组 [,int])  统计数组的个数，如果参数为字符串包括空字符串，返回int 1；统计字符串用strlen();可选参数默认为0 ，表示统计数组0层，设置int后，就统计0,1,2---int 层一共的元素多少个数
例：
$arr=[["hehe","haha"],"bbb","xxx","aaa","bbb"];
echo count($arr,1);
结果为7个；
j array_count_values(数组)  返回一个数组，键名是原来数组的值，元素值为出现次数；

k array_unique(数组)  移出数组中重复的值（保留第一个出现的值和键）；

l array_filter(数组 [,callback])用回调函数过滤数组中的单元；默认情况下（没有回调函数），数组中值为假值（如：'',null,false）会被过滤（空格不是假值哦）；回调函数接收一个变量（数组中每个元素依次赋值给该变量），回调函数返回true，则该数组元素保留，返回false，则删除（是在新的数组中删除，对原数组没影响），返回的新数组并不会重新索引，如果需要用array_values();
例：
$arr=[-1,0,1,2];
var_dump(array_filter($arr,function($val){
	return ($val>0);
}));

m  array_walk(数组（自动形成引用），callback [,另外传入回执函数参数]) 对数组的每个成员应用用户函数，返回bool；（好像只有这个函数，操作的是本数组，没有返回新数组）
例：
$arr=[-1,0,1,2];
array_walk($arr,function($value,$key,$str){
  	$value++;
	echo $key.$str.$value."<br />";
},"=>");  //注意有这个参数，才有回调函数中第三个参数；
备注：如果要改变原数组，则回调函数参数需变成&$value（一般都采用引用）;****

n array_map(callback，数组1 [,数组2---]) :将回调函数作用在给定数组的值(注意是数组的值，看下例)上，并且数组可以不止一个，返回值为数组，简而言之：回执函数依次同时操作多个数组  的第一个元素、第二个元素...，虽然回执函数中有return(但这个返回结果应该赋值在最终结果$result[]上)，array_map最终返回0层为索引数组的数组；
例：
$arr=[-1,0,1,2];
$brr=["one","two","three"];
$crr=["hehe","haha"];
function myfun($a,$b,$c){
	echo $b.$a.$c."<br />";	
	return $b.$a.$c;    //注意返回数组元素的值是回调函数返回的值构成的；
}
$next_arr=array_map("myfun",$arr,$brr,$crr);
var_dump($next_arr);
备注：array_map（null,$arr,$brr,$crr);作用：形成二位数组，将$arr,$brr和$crr的第一个元素组成一个数组1，将$arr,$brr和$crr的第二个元素组成二个数组2，以此类推，$arr,$brr和$crr中没有元素了用空代替，将数组1，数组2···有形成新的数组；

35  排序
A 冒泡排序：通过两两比较，每次飘一个数上去；
例：
$arr=[0,1,2,3,4,5,6,7,8,9];
$len=count($arr);
for($i=0;$i<$len-1;$i++){
	for($j=0;$j<$len-$i-1;$j++){
		if($arr[$j]<$arr[$j+1]){
   		$tmp=$arr[$j];
  		$arr[$j]=$arr[$j+1];
    		$arr[$j+1]=$tmp;
		}
	}
}
B 排序函数：总体升序的话，字符串要在整型的前面，如：["abc",10]，但是不同的排序方法对数字的字符串是不同的，如sort排序系列，无论升序还是降序总是把数字字符串排在最前面，如["10","a",10]，但是函数 array_multisort()，无论升序还是降序总把数字字符串排在最后，如["a",10，"10"]，以上说的数字字符串包括'12sdf'形式；
sort（数组引用 [,int]）  对数组排序（升序），并重新索引，返回bool，数字和字符串都适用，第二个参数为预定义常量（很少这个参数）；
rsort 对数组排序（降序）；
ksort 对数组按照键名排序；
krsort 对数组按照键名逆向排序；
asort 对数组进行排序并保持索引关系（特别适合关联数组排序）；
arsort 对数组进行逆向排序并保持索引关系；
natsort 用“自然排序”算法对数组进行排序；
natcasesort 用“自然排序”算法对数组进行不区分大小写字母的排序；
备注：自然排序特别适合 file1.txt file2,txt等类型排序；
usort(数组，callback($a,$b){}) 使用用户自定义的比较函数对数组中的值进行排序；
usort($arr,function($a,$b){
	$alen=strlen($a);
 	$blen=strlen($b);
 	if($alen == $blen){
		return 0;
	}else{
		return ($alen>$blen) ? -1:1; //只要区分正负整数就行-2:3也行
	}
});
备注：回调函数返回：正数调换$a,$b的对应元素位置，返回0不调换（位置模糊），返回负数不调换位置；后面两个函数用法雷同；
uasort 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联；
uksort 使用用户自定义的比较函数对数组中的键名进行排序；
array_multisort 对多个数组或多维数组进行排序；
语法：bool array_multisort ( array $ar1 [, mixed $arg [, mixed $... [, array $... ]]] )；
备注：
排序顺序标志： 
■SORT_ASC - 按照上升顺序排序
■SORT_DESC - 按照下降顺序排序
排序类型标志： 
■SORT_REGULAR - 将项目按照通常方法比较
■SORT_NUMERIC - 将项目按照数值比较
■SORT_STRING - 将项目按照字符串比较 

第一个数组只依据该数组后面的排序属性标志和排列类型标志；默认升序和SORT_REGULAR排序。
第二个数组排列先参照第一个数组元素位置的改变，相对应改变自己位置（只有第一个数组元素值相同情况下，即无法排列某些元素位置，再通过自身的排序标志排列（只有这时排序标志才有作用））
第三个数组排序先参照第一个数组排列，再参照第二个数组排列，如果还有无法排列元素，然后再依据排列标志进行排列；
第四个依次类推；
例：
array_multisort($age, SORT_ASC, SORT_STRING,$name, SORT_DESC,$arr);
备注：所有排序的函数都是操作原数组，操作原数组函数还包括array_walk(),array_splice();


36 数组拆分
A array_slice(数组，int [,length [,bool]])  返回一个数组，返回数组从原来数组中下标为int（可以为负数）的元素开始（包括该元素），然后再向后取length-1个元素，没有length，默认到结尾，最后一个参数为true，则保留原数组中的下标，默认为false，重新索引；
B array_splice(数组（自动为引用），int [,length [,其他值val]])   把数组的一部分去掉并可以用其他值代替，语法中的 其他值val 可以是数组，字符串等类型的值；
上面两个函数区别：前者保留满足条件的值，赋值给新数组，后者也可以保留满足条件的值，赋值给新数组，但它操作原数组删除了满足条件的值，并可以用其他值代替删除部分；

C array_combine(数组1，数组2);返回新的数组，数组1作为新数组下标，数组2作为新数组值（数组1和数组2的元素个数必须相等）；

D 数组相加（即+），下标相同会覆盖，前面覆盖后面的；

E array_merge(数组1，数组2[，数组---])，两个数组中元素连接在一起，重新索引返回成新数组；
但如果关联数组的下标相同，则会后面的覆盖前面的元素并占有前面元素的位置；如果参数只有一个参数数组（索引数组），那么将会重新索引下标；

结论:用加号合并数组:既考虑数字索引的键值对,也考虑字符串索引的键值对,用前边数组的值覆盖后边的键名相同的值;
用array_merge()合并数组:只考虑字符串索引的键值对,用后边数组的值覆盖掉前面数组中键名相同的值,数字索引的值则不覆盖,同时保留

F array_intersect(数组1，数组2 [,数组3---]) 返回一个新数组，新数组为数组1和数组2的交集（就是参数数组中共有的值，下标可以不同）；
   array_diff(数组1，数组2 [,数组3---]) 返回一个新数组，新数组为数组1和数组2的差集（返回数组1中独有的元素值，该元素不存在于数组2，数组3---）；

37 模拟栈
A 压入栈：array_push(数组，压入数据)；先进入的数据，在数组中排在前面；
例：array_push($arr,1,2,3);

B 弹出栈：array_pop($arr);  弹出在数组中排在最后的一个元素；
例：
$arr=[];
array_push($arr,1,2,3,4);
array_pop($arr);   //结果弹出4
备注：注意弹出顺序，像弹夹一样，先入后出；

C array_unshift(数组，进入数据)；先进入的数据，在数组中排在后面(进入数据必须一个个进，才有效，一起进入作用和array_push()一样)；
D array_shift(数组)；弹出在数组中排在最前的一个元素；
***备注：

array_push($arr,1);array_push($arr,2);array_push($arr,3);结果[1,2,3];即push两种写法操作效果相同
array_unshift($arr,1);array_unshift($arr,2);array_unshift($arr,3);结果[3,2,1];即unshift两种写法效果相反；

38 其他数组函数；
array_rand(数组 [,int]);  返回从数组中随机取出一个或int个单元(这个就是数组)的下标；

shuffle(数组)，打乱一个数组中元素的排序（操作本数组）；

array_sum（数组），计算数组中所有元素的值得和（元素值为字符串，按字符串自动转化为整型，然后再计算，如"12hehe",则算为整型12；）；

range() ,建立一个包含指定范围单元的数组；
语法：range(low,high [,step]);
例：$arr=range(0,5);结果[0,1,2,3,4,5];注意：包含符合条件的边界（因为有step，可能右面边界不符合要求），如果range(5,0)则反过来[5,4,3,2,1,0]；

array_fill(开始下标，共填充个数，填充值)；创建返回一个数组；
例：$arr=array_fill(0,5,'hehe');

array_replace();使用传递的数组替换第一个数组的元素，说明：数组0层的键为数组元素替换的最小单元，如数组$arr[1],就会被替换数组的$arr2[1]所替换；看手册；

array_replace_recursive ();使用传递的数组递归替换第一个数组的元素，说明：数组的最里层为数组元素的替换单元，$arr[1][2]...才是被替换的最小单元；
例2：
$base = array('citrus' => array( "orange") , 'berries' => array("blackberry", "raspberry"), );
$replacements = array('citrus' => array('pineapple'), 'berries' => 1);
$basket = array_replace_recursive($base, $replacements);
print_r($basket);
结果：
Array ( [citrus] => Array ( [0] => pineapple ) [berries] => 1 )

例2：
<?php
$base = array('citrus' => array( "orange") , 'berries' => array("blackberry", "raspberry"), );
$replacements = array('citrus' => array('pineapple'), 'berries' => array('blueberry'));

$basket = array_replace_recursive($base, $replacements);
print_r($basket);
结果：
Array
(
    [citrus] => Array
        (
            [0] => pineapple
        )

    [berries] => Array
        (
            [0] => blueberry
            [1] => raspberry
        )

)
备注：如果数组里层有替换，那么外层将不替换(即使外层满足替换条件)，如果数组里层没有替换，外层如果满足替换条件，则会替换；


array array_pad ( array $input , int $pad_size , mixed $pad_value  );用值将数组填补到指定长度

compact() — 建立一个数组，包括变量名和它们的值 ,即把变量名传入该函数，变量名对应变量的值自动成为数组的值；
例：$a=2,$b=3;$arr =compact("a","b");var_dump($arr);
extract() — 从数组中将变量导入到当前的符号表，作用于compact相反；

第七章
37 
A 类是对象的描述，创建类，才能创建对象；
对象两个特性：属性和行为；
类可以放在单独二级文件名的文件中；如：test.class.php
类的简单声明:
[修饰符]  class 类名 {
[成员属性]
[成员方法]
}          （类名最好采用每个单词都大写）
完整格式声明：
[修饰符] class 类名 [extends 父类] [implements 接口1 [,接口2...]] {
[成员属性]
[成员方法]
} 
备注：
成员属性声明前面必须有修饰词 ：public  , static, var, private,protected等
成员方法声明可加可不加修饰词；
****调用成员属性或者方法，需要用      对象->属性名或者方法名（属性名不要$）;

B 创建新对象
语法：变量=new 类名();   说明：后面括号可有可无；

C 只要是对象中的成员，就必须使用这个对象才能访问到这个对象内部的属性和方法；
$this 为对象本身的引用（在class内部也行），用法都要$this->属性；注意符号与=>区分哦！

D 构造方法：
a 是对象创建完成后，第一个 自动调用的方法（虽说第一，但是位置不要求）；
b 方法名称比较特殊 ，可以和类名相同的方法名（也可以用__construct()，采用这个魔术方法）；
c 给对象中的成员赋初值；

E 析构方法：对象释放前（删除了对象引用或者引用为空）自动调用方法；析构方法没有参数；
语法：function __destruct(){}
适用情况：释放数据库资源；

38 对象特性
A 封装性：把对象中的成员属性和成员方法加上访问修饰符，使其尽可能隐藏对象的内部细节，以达到对成员的访问控制（切记不是拒绝访问）。
关键字：（针对属性或者方法）
public  公有的，为默认；
private 设置了该关键字的属性或者方法只能被类中其他方法调用，不能被对象直接调用；
protected 保护
以下具有√表示在类代码中或者对象直接调用可以使用具有该关键字的成员属性或者成员方法；
		private 		protected		public
自己类	   √		  	  √			   √
子类			   			  √			   √
其他类									   √
对象										   √
备注：虽然不能直接调用，但是可以通过“找关系”间接调用；如对象无法调用private的属性，但是可以调用public方法，再由public方法去调用private属性；


B 继承性
a PHP的采用单继承，就是一个类只能有一个父类，当然父类还可以有父类；（只有一个父亲，可以有多个子女）
b 子类用extends 继承父类，子类可以将父类所有内容都继承（所有都继承，不代表可以所有都使用）
c  private 这个是私有的，只能自己用，不能被别人使用，包括自己的子类；
d  protected 是保护的权限，只能是自己和自己的子类可以使用，不能在外面用（外面是指父类和子类代码以外，就算用子类的创建的对象，在外面也不能调用？父类的对象）；
e  public 公开的权限，都可以使用（默认）；

f  继承中的重载（别名：覆盖）：在子类中可以写和父类的同名的方法；（但同一个类中方法不能重名）
g  类调用方法
语法：    类名::方法；（调用成员属性也是，类名::$属性名）
例：(在子类中调用与父类重名方法run()，因为不重名可以用$this->run())
function Run(){
	Person::Run();
	//扩充代码；
}
备注：常用 parent代替父类类名，如：parent::Run();
子类调用父类方法：
子类方法与父类方法不重名：$this->方法；（因为如果重名，这句代码表示调用子类中方法），优先调用自身方法；
子类方法与父类方法重名：parent::方法；（当然这个不重名也可以调用），永远调用父类方法；
备注：php类的属性和方法都采用独立的就近原则，即parent::方法，方法中采用的属性，依然从当前类开始就近原则，而不是直接调用父类的
例：
function __construct($name,$age,$height,$weight){
	parent::__construct($name,$age,$height);
	$this->weight=$weight;
}

h 权限问题：子类只能大于或者等于父类权限，不能小于（针对同一成员权限）；(简记：越来越大)
权限：private < protected < public;

C 

39 类注意事项
a 变量声明前面有关键字；
b 变量和方法调用前面需要有对象，类中调用变量需要$this->

40 魔术方法：提供一种改变封装好的类的属性和方法的途径；
__get()   在直接访问（如：输出等）私有属性时自动调用；
function __get($var){}     //调用时会把属性名称赋值给$var;
例：
function __get($var){
	return $this->$var;
}
__set()    在设置直接设置（如：赋值等）私有属性时自动调用，两个参数；
function __set($var,$value)  //第一个参数为属性名，第二个参数为属性值（对象将设置的新值，不是原来的值）；
例：
function __set($var,$value){
	$this->$var=$value;
}
//上例作用就是让对象设置新值；
__isset()  在使用isset()判断一个私有属性是否存在时自动调用，参数是属性名；判断public属性直接可以用isset();
function __isset($proname)   //$proname 为属性名
例：
function __isset($var){
	return isset($this->$var);
}
//上例作用是允许判断私有属性；
__unset()  在使用unset()删除一个私有属性时自动调用，参数是属性名；删除public属性可以直接用unset();
function __unset($proname)   //$proname为属性名
例：
function __unset($var){
	unset($this->$var);
}
//上例作用是允许删除私有属性；
备注：以上四个魔术方法共同特点：a 针对私有属性（protected属性也适用）；b 触发后自动调用；

41 关键字
A instanceof 判断对象是否是某个类的类型，返回布尔型；注意：如果对象属于子类类型，那么该对象也属于父类类型；
语法： 对象 instanceof 类名；
例：
if($per1 instanceof person){		//注意后面类名没有引号
	echo "是这个类的对象";
}else{
	echo "不是这个类的对象";
}

B final
 a 可以修饰类   ----作用：该类就不能扩展（即不能就子类），使用情况：不让别人扩展
 b 可以修饰方法----作用：该方法就不能在子类中被覆盖，即子类不能和父类该方法重名，但是子类的其他方法也可以调用该方法；  使用情况：该方法就是最终方法，不让别人修改；
c 不能修饰成员属性；
例：
function hehe(){
	parent::hehe();
	echo "这是子类加上的";
}

C static 可以修饰属性和方法，不能修饰类,设置了static关键,表示成员属于类,不属于某个对象；
a 使用static 修饰成员属性，存在内存的初始化静态段（即只存储一次）；
b 可以被所有同一个类的对象共用；
c 类在加载到内存时，就已经将静态的成员加到了内存（没有对象时）；
d 静态的成员一定要使用类来访问（不能用对象来访问）；
e  static修饰成员后，也可以重新赋值，还可以在该类的代码中调用；例：person::$height=160;
f  self 可以在类中的方法中，代表自己类，例：self::$height;
g  静态成员一旦被加载，只有脚本结束才释放；
h  能用静态方法的时候，尽量用静态方法（效率高）；
i  静态方法不能调用非静态成员；（因为没有对象，$this->不能用）
例：
 class Person {
	protected $name;
	protected $age;
	static protected $height=172;  //static在这里赋值
	 function __construct($name,$age){
		$this->name=$name;
		$this->age=$age;		

	}
	function hehe(){
		echo $this->name;
	}

}
class Neo extends Person{
	public $weight;
	function __construct($name,$age,$weight){
		parent::__construct($name,$age);
		$this->weight=$weight;
	}
	function hehe(){
		echo person::$height; //这儿与对象调用不同，有$符号；
	}
}

D const 关键字   修饰成员属性为常量，也只能修饰成员属性（属于类的，不属于具体对象），有了const关键字，就不能用private、public、protected、static等关键字了；
a 常量建议使用大写，不能使用$;
b 常量一定要在声明时赋上初值；
c 常量的访问方式和static的访问方式相同（但常量名没有$），但只能读；
	c-a 在外部使用   	类名::常量名；
	c-b 在类的内部		self :: 常量名；
备注：在类里不能使用define()声明常量，还得注意：常量是标量，不能为数组和对象，也存储在初始化静态段；并且在引用时不用外面加{}，只能用连接符 . ;
注意：
a 父类方法中声明静态（有关键字static），那么该方法在子类中能重载，但也要声明为静态，即有关键字static；
b 非静态方法可以访问(即代码中包含)静态属性和静态方法，方式	self::$属性名，self::方法名();
   静态方法只能访问静态属性；
c 在类代码中：
  静态属性和方法只能采用 :: 方式访问，如self::$name; self::方法名();
  非静态属性只能用$this->属性名   访问，如$this->name;
  非静态方法既可以用$this->方法名()，也可以用self::方法名()访问；也就是说方法无论静态还是非静态可以统一采用 ::  方式访问；
备注：当然在类代码外，静态还是用 类::方法，非静态用$this->方法;

总结：无论代码在任何地方，静态方法与属性用 :: (常量属性也一样),非静态方法与属性用 $this->
 



42 设计模式:完成某项功能最好的方法;
A 单态(单例,单件)设计模式:一个类只能创建一个对象(虽然只能创建一个,但是这个对象属性还是可以更改的);
a 如果想让一个类,只能有一个对象,就要先让这个类不能创建对象,即将构造方法设置关键字private;
b 可以在类的内部使用一个静态方法来创建一个对象,并返回对象;
例:
class Person {
	static $Obj=null;	
	protected $name;
	protected $age;
	private function __construct($name,$age){
		$this->name=$name;
		$this->age=$age;		
	}
	static function getObj($name,$age){
		if(is_null(self::$Obj)){
			return self::$Obj=new self($name,$age);//这个时候就可以new一个对象，因为有权限了；
		}else{
			return self::$Obj;
		}
		
	}
	public function show(){
		//说明：name属性关键字为protected，那么访问还是得用$this
		echo '我的名字叫'.$this->name.',我的年龄：'.$this->age;
	}
	function __destruct(){
		echo "#######"."<br />";
	}
}

$obj = Person::getObj('neo',25);	//因为构造方法私有，不能用new创建对象，因为没有权限；
$obj->show();

备注:单态设计模式要求,
a 类的一个成员属性（对象）值为null,关键字为static;关键字static的原因：因为构造函数的关键字为private，那么不能用new来创建对象，只能通过类调用方法，如：$obj=Person::getObj('neo',25);而该方法就必须关键字为static，而静态方法只能调用静态属性，所有该属性必须为静态；
b 构造函数关键字为private;
c 类的一个成员方法关键字为static;

43 魔术方法
特点：a 自动调用 ；b 方法名都以“__”开头；c 所有魔术方法方法名都是固定的；d 如果不写出魔术方法代码，就不存在（即没有默认功能）；

A __toString()  
a 是在直接使用 echo print printf 输出一个对象引用时，自动调用这个方法；
b 将对象的  基本信息  放在 __toString() 方法内部，形成字符串返回；
c __toString()方法中不能有参数，而且必须返回一个字符串；
例：
function __toString(){
	return '这个对象有 $name 和 $age 两个参数；';
}

B __clone()  
a 是在克隆对象时自动调用的方法；
b 作用：和构造方法一样，是对新克隆的对象进行初始化；但注意：__clone()不能有参数；
c __clone(){}中代码的$this代表的是副本（即新对象），有点不好使的 $that代表原本（即原对象）；

备注：克隆对象：使用 clone 关键字复制了对象，如：$p2=clone $p;注意不是$p2=$p ;这个只是复制了地址，对象还是一个；

C __call()
a 就是在调用一个对象中不存在的方法时，自动调用该方法；
b 必须有两个参数：第一个是调用不存在的方法的方法名，第二个参数（是一个数组）是调用这个不存在的方法的参数；
c 作用：可以写提示（但不是主要功能），将方法的功能相似的，但方法名不同，就采用这个方式来完成；
注意：这个支持不同方法，不支持静态方法，即用类调用静态不存在方法时（例person::sdf()），__call()不会自动调用；
例：
 class Person {
	public $marr=["aaa","bbb","ccc"];
	function __call($method,$args){
		if(in_array($method,$this->marr)){
			echo $args[0];
		}else{
			echo "对不起！".$method."方法不存在。";
		}
	}
}


D __sleep() 在对象串行化时（serialize()）自动调用的方法，适用情况：对象太大，没必要保存，就保留对象的一些属性就行，就需要串行化对象；
作用：可以设置需要串行化的对象的属性；
只要在这个方法中，返回一个数组，在数组中声明了那个属性名，那个属性名就会被串行化，没有在这个数组中的就不会被串行化，这个方法默认全部属性都串行化；
例：
__sleep(){
	return ["name","age"];
}
备注：将对象的name和age属性串行化；

E __wakeup() 将对象反串行化(unserialize())之前自动调用的方法，就是把字符串转化为对象之前，要做什么，比如：这个对象存在，要先连接数据库啥的，或者为串行化对象属性赋值（即改变原来的属性值）；
例：
function __wakeup(){
	$this->age=25;
}
作用：对串行化回来的对象，进行初始化；	

F static __set_state(数组) 方法，在使用 var_export()方法时(var_export()的第一个参数为对象，第二个参数为true)，导出一个类的信息时自动调用；注意__set_state()必须是静态的（即关键字static），该参数必须是一个数组，其中包含按array('property'=>value...)格式排列的类属性（对象属性和值构成的数组）；__set_state()返回什么数据，var_export()就得到什么数据，只不过加工成了字符串而已；
备注：这个__set_state()可以选择性的复制或者修改对象属性到新的对象；

例：
 class Person {
	var $name;
	var $id;
	 function __construct($name,$id){
		$this->name=$name;
		$this->id=$id;
	}
	static function __set_state($arr){   //注意必须有static 关键字；
		$newobj= new self("名",0);//这里的参数只有声明作用，因为赋值被后面的代替了	
		$newobj ->name=$arr["name"];//这里复制原对象的name属性给新对象；
		$newobj ->id=$arr["id"];//这里复制原对象的id属性值给新对象，这也是完全可以改变的，如$newobj ->id=100;
		return $newobj;//返回啥数据，var_export()就得到什么数据，只不过加工成了字符串而已；
	}
}
$obj=new Person("hehe",12);
$obj->name="znem";
eval('$b='.var_export($obj,true).";"); //'$b'为单引号哦！
var_dump($b);


a   eval()函数作用：检查并执行PHP代码，相当于php解析器（把字符串剥离成代码）；
例：
$str="echo 'abc';"
eval($str);
结果显示：abc

b  var_export(mixed $var [,bool]); 情况1：没有第二个参数，打印传递给该方法的变量结构信息，且信息是合法的php代码（即该代码可以直接当做php代码赋值给一个变量，而这个变量会取得和被var_export()一样的类型的值）；情况二：有第二个参数为true，将不打印信息，而是将该信息作为合法php代码（上例中返回为字符串类型）返回；

G __invoke()方法，是在对象实例之后，直接向变量函数一样调用时自动调用这个方法，可以有参数，当然要和$obj($a,$b)中的参数一致；
例（部分代码）：
...
function __invoke($a,$b){
	echo $a.$b;
}
...
$obj=new Person("hehe",12);
$obj("sdf",20);

H static __callstatic() ,调用不存在静态方法时，自动调用；第一个参数为不存在方法，第二个参数为不存在方法的参数构成的数组；特别注意：前面必须加关键字static；
例：
...
static function __callstatic($method,$args){
	echo $method.$args[1];
}
...
person::hello("sdf",20);

I function __autoload($classname){} ,作用：自动加载文件，且不会重复加载；只要在脚本中，需要加载类的时候（必须用到类名），就会自动调用这个方法；注意：这个函数通常写在类外，当然也可以写在类里；
完成加载所需条件：
a  一个二级文件（如：test.class.php）只能包含一个类（当然最开始代码也得有<?php 哦!）；
b 文件名（指除开.class.php部分且小写）和类名（首字母大写）除了大小写其余要一样；
例：
<?php
function __autoload($classname){
	include strtolower($classname).".class.php";//这里可以设置路径，现在表示同一文件夹
	//include "新建文件夹/".strtolower($classname).".class.php";
}
$obj=new Person("liu",20);
echo $obj;
44 
A 对象串行化
a 对象串行化（序列化）：将对象变成字符串（不用看懂）；将字符串转回对象叫反串行化；
适用情况：a 将对象在网络中传输 ；b 将对象持久保存；
 序列化语法：serialize(对象) ；返回值为字符串；

b 反序列化语法：unserialize(字符串)；返回值为对象；
例：
$str = serialize($obj);
$obj=unserialize($str);
备注：以上方法只能在php中用，优点：可以使用魔术方法，降低传输数据；

B 数组串行化 json --JavaScript object；
a   json_encode — 对变量进行 JSON 编码
串行化语法：string json_encode ( mixed $value );，返回字符串，待编码的 value ，除了resource类型之外，可以为任何数据类型 ；

b  json_decode — 对 JSON 格式的字符串进行解码；
反串行化语法：mixed json_decode ( string $json [, bool $assoc ] ) 接受一个 JSON 格式的字符串并且把它转换为 PHP 变量；参数一位待解码的 json string 格式的字符串。参数二为 TRUE 时，将返回 array 而非 object(默认为对象) 。  
备注：以上json数据可以跨设备跨语言用；
例：
$per1=new person("hehe",12);	
$str=json_encode($per1);		
echo $str."<br />";				
$p=json_decode($str,true);		
var_dump($p);
备注：其他的字符串、整型、浮点型、布尔型json_encode()和json_decode()没有作用，还是该类型（当然值也不变）；数组和对象数据通过json_encode()将转化为JSON格式字符串，将JSON格式字符串通过json_decode()默认转化为对象，若第二个参数为true，则转化为数组；

45 抽象 :抽象方法一定要在抽象类中，但抽象类不一定要有抽象方法；
A 抽象方法：一个方法如果没有方法体（一个方法不使用{}，直接使用分号结束），则这个方法就是抽象方法；
a 声明一个方法不使用{}，直接使用分号结束（这才叫没有方法体）；
b 如果是抽象方法，必须使用abstract (抽象关键字来修饰)；

B 抽象类：
a 如果一个类中有一个方法为抽象方法，则这个类为抽象类；
b 如果声明一个抽象类，则这个类必须使用abstract关键字来修饰；
注意：
a  只要使用abstract修饰的类，就是抽象类（不一定要包含抽象方法）；
b 抽象类是一种特殊的类，特殊在抽象类可以有抽象方法；
c 除了在抽象类中可以有抽象方法以外和正常类完全一样；
d 抽象类不能实例化，即不能创建对象；
e 如果看见抽象类，就必须写这个类的子类，将抽象类中的全部抽象方法覆盖（即重名，加上方法体），如果不是全部覆盖，那么子类也是抽象类；
作用：
a 抽象方法：规定了子类必须有这个方法（没有则不能实例化对象），功能交给子类；
b 抽象类：要求子类的结构，所以抽象类就是一个规范；

45 接口：接口是一种特殊的抽象类；
a 抽象类和接口中都有抽象方法；
b 抽象类和接口都不能创建实例对象；
c 抽象类和接口的作用相同，都是起一种规范作用；

接口相对于抽象类的特殊点：
a 接口中的方法，必须全部是抽象方法（不能用不抽象的方法），所以在接口中的抽象方法不需要是abstract关键字；
b 接口中的成员属性，必须是常量（不能有变量）
c 接口中的所有权限必须是公有的（默认即public）
d 声明接口不使用class ，而是使用 interface；

接口应用细节：
a 可以使用extends 让一个接口继承另一个接口；注意：接口继承接口，只有扩展新抽象方法，没有覆盖的关系；
b 可以使用一个类来实现接口中的全部方法，也可以使用抽象类来实现接口中的部分方法；类与接口，抽象类与接口，存在覆盖（重写）关系；
c 就不要使用extends这个关键字，使用implements实现；
d extends 继承（扩展），这个在php中，一个类只能有一个父类；
e 一个类可以在继承另一个类的同时可以使用implements实现一个或者多个接口，一定要先继承，然后在接口；
f 实现多个接口，只需要用逗号分开多个接口名；
***g 在子类对抽象方法进行覆盖（重名）时，不能使用 static 关键字，抽象方法包括从抽象类继承的，或者从接口实现过来的； 
例： [abstract]  class  类名 extends 父类名 implements 接口1名, 接口2名 {}
备注：接口与接口之间，类与类（包括抽象类）之间，都用extends，而接口与类（包括抽象类）之间用implements；

46 多态性
A 多态就是为程序扩展准备；技术：a 必须有继承关系，父类最好是接口或者抽象类；
***额外信息：方法中可以用接口、类或者数组等来限制参数；
例：function usbUSB （USB $usb）{}   备注：只能传接口USB类型的对象；
ucfirst(字符串):将字符串首字母大写；
***猜测：__autoload()连引用的类的父类也自动引用，即主程序通过该函数自动调用类（该类继承了一个文件的类2），类2也被自动调用；

***一个类的构造函数中有形参，而创建对象时，却不用给出具体值，就给出类型就能创建对象；
例：__construct($arr){
	$this->name=$arr['name'];
}
$obj=new Person(array());
备注：上例也是可以创建对象的；

**猜测：页面点击链接或者提交等操作，即使是链接或者提交到本页面也要重新执行所有代码（除非用AJAX）；
**猜测：echo 字符串；字符串先交给浏览器解析，浏览器能识别的代码，则执行代码，不能则输出为字符串；

类和对象有关的函数：php手册-函数参考-与变量和类型有关的扩展-Classes/Objects;（php手册收藏夹里有）

写多态代码步骤；
a 写出规范
b 按照规范写出一个具体类（可以用于调试）
c 写主程序；

47 命名空间（名字空间），作用：解决常量、函数和类命名冲突问题；
简记：常含泪水
备注：命名空间名不区分大小；
a 常量 b 函数 c 类
A 声明：namespace 空间名；
例：namespace neo;
B 在namespace声明命名空间的代码上面，不能有任何php代码和html内容输出（除了declare，但这个基本不用了），声明命名空间只能是第一条代码，但肯定要在<?php之后啦，***而且<?php要顶头，不要空格或者换行；
C 多个文件中可以用相同的命名空间名；同样，一个文件中也可以有多个命名空间（虽然不建议）
D 子命名空间：与目录和文件的关系很象，PHP 命名空间也允许指定层次化的命名空间的名称
E 连续定义多个命名空间，以最后一个为主；如namespace neo；namespace lydia；则空间lydia把neo覆盖了；
F 在实际项目中，不建议在同一文件中使用多个命名空间，但如果已经用了多个命名空间，那么不能在大括号外有任何代码，如果是全局代码，可以写在namespace {代码写在这里；}，即命名空间没有名；
***G 注意：动态的类名称、函数名称和常量名称需要用完整路径（当然有没有最前面的\是没区别的），动态体现在变量被类名称、函数名称或者常量名称赋值；
例1:
$a='mySpace\child\neo';
$b=__NAMESPACE__.'\neo';//以上两行代码作用一样，但是采用后者，还要注意最好用单引号（防止                                           //     \在双引号中产生转义）；
$a();
$b();
***H 关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符,如果命名空间不存在了，那么程序也不会出错。 如下例@;

I 命名空间别名：针对比较复杂的命名空间，用use关键字；
例：use net\lampbrother\www as lamp ;     //lamp就可以代替前面的空间名用了；
例：use net\lampbrother\www;   	//如果没有as，则最后\后的就直接是别名；

J 导入   也可以用关键字use，包括类导入和空间导入，先用include 导入文件，use 命名空间；因为如果设置了命名空间即使用了include，文件中类、函数和常量还是不能用（没有命名空间情况下，可以直接引用include文件）；即使一个空间中写出另一个完整命名空间还是不能用；
例：
include "func.inc.php";
use \func;  //有命名空间情况下，必须要用这一步，不然不能调用func.inc.php中func类；
func::test();

备注：只有类和空间能导入，因为类名称总是解析到当前命名空间，如果当前空间中没有类，则直接错误，而不会向上调用

特别注意：向上调用只能去取全局命名空间中的常量和函数，不是指use引用 命名空间或者上级空间，如：Home\user，不会去取Home空间中的常量和函数；

函数和常量不能导入，因为会自动向上调用（向上只向全局）；
***如果直接在名称前加 \ 就表示全局空间（没有命名的空间）中的名称，即使该名称位于其他的命名空间中也一样；
*******************************************

命名空间--总结：(主要看下面记忆部分)

A 导入和别名（用use）的作用都是导入命名空间，导入命名空间的作用是调用命名空间中的代码（重名函数，重名常量和重名类，当然还有其他，先还要通过include引入文件）；
B 导入非全局类（在有名字的命名空间内声明的类），可以为这个类设置别名或者直接用该类名(不过直接用，该文件中就不能再声明该类)访问该类；
例：
use My\Full\Classname as Another; 
$obj = new Another; // 实例化 My\Full\Classname　对象
C 导入空间，需要注意的是导入空间后，也不能直接调用函数或者常量，要在调用函数前面加导入空间时产生的*别名*（都用的是别名），如果用use NS as Another   方式导入的空间 ，那么直接是：Another\函数；如果用use NS\NSname 方式导入的空间，则用 NSname\函数；
例：use My\Full\NSname;
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func

D 导入全局类（即在无名空间内或者系统预定义类）；
例：use \ArrayObject;
$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
// 如果不使用 "use \ArrayObject" ，则实例化一个 本命名空间中的ArrayObject类 对象
？？？？？导入空间后，还要专门导入类？？
例2：
<?php
namespace mySpace\child;  //child为mySpace的子命名空间，注意符号是\不是/哦；
const ROOT="lydia";
function neo(){
	echo "33333333<br />";
}
class func{
	static function test(){
		echo __METHOD__;
	}
}
echo ROOT."<br/>";	 //相当于相对路径
echo \mySpace\child\ROOT.'<br />'; //相当于绝对路径；
neo();
namespace\neo();         //关键字namespace可以代替路径；例@
func::test();
\mySpace\child\func::test();
备注：当然命名空间也可以采用namespace mySpace\child {代码块}方式，这种方法才能在同一个文件中声明多个命名空间；
超级注意事项：有命名空间文件，该文件不能为utf-8编码，不然namespace NS_name;就算是第一行代码，也会出错；


命名空间使用（记忆）：namespace myspace;
a 使用本命名空间中的常量、函数、类
方式一：（采用）
直接使用，不加任何东西，如：echo ROOT; func(); $obj = classname();
方式二：
在常量、函数、类前面加namespace\	如：echo namespace\ROOT; namespace\func(); $obj = namespace\classname();

b 使用全局空间（无名命名空间）中的常量、函数、类
说明：具体命名空间中除define()定义常量不能重名外，其他方式包括const 声明常量，以及函数和类都可以与全局空间的常量、函数、类重名；
条件：如果全局中间在本文件外，要使用include "文件名";才行
方式一：（无论是否该空间中常量、函数、类是否重名都适用）
在常量、函数、类前面加 \	如：echo \ROOT; \func(); $obj = \classname();
方式二:如果该空间中没有的常量或者函数，则直接使用常量或者函数名可以调用全局空间中的对应常量或者函数；特别注意：即使该命名空间中没有类ClassName,也不能直接使用ClassName调用全局中间的该类，必须加\ClassName

c 使用另外命名空间的常量、函数、类
猜测：除父级为全局空间外，父级命名空间同样适用这个，即父级命名空间只是在空间名称上分级，如Home\User 仅此而已，操作上与其他空间并无两样；
方式一：（采用，直接导入空间）
条件1：如果别的命名空间在本文件外，则用include "文件名";才行
条件2：使用use导入空间且为空间命别名；
           use net\lampbrother\www as lamp ;   导入空间并用别名lamp代替空间；
或者    use net\lampbrother\www;   	      导入空间并用别名www代替空间；那么该命名空间中的常量、函数和类都可以使用
在常量、函数、类前面加   别名\ 	如：echo lamp\ROOT; lamp\func(); $obj = lamp\classname();

方式二：（了解，ThinkPHP采用了；直接导入类，常量和函数不能使用，如果要使用常量或者函数，需要再导入命名空间，也就说导入类和导入命名空间可以同时存在）
条件1：如果别的命名空间在本文件外，则用include "文件名";才行
条件2：使用use导入空间中的类；
           use net\lampbrother\className as otherName ;   导入空间并用别名otherName代替空间；
或者    use net\lampbrother\className;  这种方式只能使用导入命名空间中的类，不能使用其中的常量和函数(即使加命名空间前缀也不行)；
这种方式分为两种情况：
A 用use直接导入(即不声明别名)，如：use region\dad;
那么可以直接使用类dad，无需加前缀(前提是该文件中不能再声明同名类dad,有则报错)
B 用use并声明类别名，如：use region\dad as da;那么需要用da来代替dad类使用，本文件中可以声明同名类dad；


备注：虽然还有其他使用方式，只用上面的规范就行了，还得记住一点，就是只有常量、函数、类需要这么用，如类中的方法，还是对象直接调用方法就行，如$obj->test();不用加任何东西；

备注2：
A  define()方式定义的常量将贯穿整个命名空间(无论是在全局空间还是非全局空间中定义的)，即定义过某个名字常量后，将不得再定义该名字常量，否则会报错，也就是说define()定义过的常量，不用理会命名空间，直接通过常量名调用；

B 用const声明的常量，是属于命名空间的，才满足上面提到的需要用: 命名空间\常量名  来引用；

精总结：(妈的，这儿太晕)
前提：必须要将文件引入(无论是include还是require)；
A 在全局空间中无论是导入非全局空间还是导入非全局空间类，必须要起别名
如：
use ns_one as othername;  //成立，即空间别名为othername
use ns_one\ns_two;        //成立，即空间别名为ns_two
use ns_one\classname;     //成立, 即类别名为classname
use ns_one\classname as othername; //成立，即类别名为othername
use ns_one;               //(特例)错误；可以直接省略这句代码，在后面也可以用ns_one\ROOT、ns_one\func()、ns_one\classname()，反而不会报错；


B 在非全局空间中导入非全局空间或者导入非全局类，不要求非得起别名；
A 中的所有例子都成立，包括:use ns_one;

C 在非全局中间中导入全局空间类；
如：
use Yii;              //成立
use \Yii;             //成立，作用跟上一句完全相同，即\为可选
use Yii as othername; //成立；

备注：use 关键字后面参数会直接以根命名空间为基准解析，所以，命名空间最左边的
\，效果一样(唯一例外是全局空间中导入非全局空间，没有起别名时会报错，即上面的
特例)，即用use \ns_one\ns_two 与use ns_one\ns_two一样的；

相对命名空间类会被解析成 代码所在命名空间 + 相对空间，如在 ns_one命名空间中的类 ns_two/className();会被解析成 ns_one\ns_two\className();
除非直接使用跟空间，即\ns_two\className()；会不变的被解析成\ns_two\className()


备注：命名空间中不能出现相同类名
下面是错误代码：
<?php
namespace fi\web;

use fi\base\Controller
class Controller extends Controller //注意：代码会对两个Controller分不清，会报错
{

}

下面是正确代码：
<?php
namespace fi\web;

class Controller extends fi\base\Controller //注意：两个类名一样，必须要完整类名，猜测：应该起能区别的别名也行；
{

}










第八章    字符串

48 字符串的声明
A 可以使用双引号 ，也可以使用单引号；双引号可以解析变量，双引号可以使用转义字符；
B 定界符 <<<

49 字符串处理函数
A 特点：
a 如果是其他类型的数据，也可以使用字符串处理函数，先将其他类型数据转化为字符串再处理；
b 字符串可以像数组一样，通过下标，来访问每个字符，但不是数组(数组和字符串的下标既可以用[]也可以用{})，建议：数组采用[],字符串采用{}；字符串为中文的，不能用下标访问，通过substr()可以截取中文，但注意截取是按字节数为单位的，即utf-8编码一个汉字要截取3三个字节；
例：$str = "hello";
echo $str{0};
备注：echo count('');count()函数时统计数组元素个数，如果统计字符串（即使为空），那么永远是1
c 中文字符串，如果为utf-8（建议采用），一个字占三个字节，如果是jb2312，每个字符占两个字节

d $str="hello";$str[2]="world";echo $str;结果：hewlo；
备注：$str已经是字符串，$str[2]="world"只是将w去替换 l ，world后面字母溢出；

e string substr ( string $string , int $start [, int $length ] ) 返回字符串 string 由 start 和 length 参数指定的子字符串。
情况一：没有第三个参数，则无论$start为正数还是负数，那么确定截取开始位置后都向右到字符串末尾，包含开始位置；负数就从倒数第一个字符为-1，然后依次向前为-2，-3···
情况二：有第三个参数且为正数，为截取字符个数（从开始位置算）；
情况三：有第三个参数且为负数，为截取字符末尾位置，返回开始位置（取）到结束位置（不取）的字符串，如果开始位置相对于结束位置的后面或者位置重合，则返回空字符串；
备注：第二个参数无论正负都是开始位置，第三个参数就要分情况；

B echo  输出字符串， 没有返回值，指令方式（没有括号时）可以打印多个值；（采用）
   print   输出一个字符串，有返回值 （打印成功，返回 int 1），不能打印多个值；
备注：两者可以有括号也可以没有，没有括号就是指令；
   var_dump()  打印类型和值，只在开发时使用；
   print_r()       打印关于变量的易于理解的信息，只在开发时使用


C die() 是exit()别名：输出一条消息并退出程序；

D printf 格式化输出；
   sprintf 格式化返回，跟printf语法一样，只是最后值（都是字符串类型）是返回；
字符串转换格式：
%% ---返回百分比符号
%b ---二进制数
%c --- 依照ASC||值的字符
%d ---带符号十进制数
%e ---科学计数法
%u --- 无符号十进制数(好像有点乱)
%f或%F ---浮点数
%o ---八进制数
%s ---字符串
%x或者%X ---十六进制数
例：
$int=100;
printf('%b,%c',$int,$int);
结果：1100100,d

E string trim ( string $str [, string $charlist ] )
此函数返回字符串 str 去除首尾空白字符后的结果。如果不指定第二个参数，trim() 将去除空格，换行符"\n" ,回车符"\r"等等。
备注：在第二个参数为字符串时，从第一个参数字符串两端向中间走，拿第一个字符去核对第二个参数中的字符（与第二个参数中字符顺序没有关系），如果存在，则删除，再拿第二个字符去核对···如果不存在，则这一边停止核对，又拿最后一个字符去核对，如果存在，则删除，再拿倒数第二个字符去核对···如果不存在，则这一边也停止核对，返回第一个参数字符串中剩余字符；
ltrim()；只删除左边，其实就是从左边开始核对，删除；
rtrim()；只删除右边，其实就是从右边开始核对，删除；
备注： 0..9或者a..z 中 ..可以设置范围；

F string str_pad ( string $input , int $pad_length [, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT ]] )
      该函数返回 input 被从左端、右端或者同时两端被填充到制定长度后的结果。如果可选的 pad_string 参数没有被指定，input 将被空格字符填充，否则它将被 pad_string 填充到指定长度。 如果 pad_length 的值是负数，小于或者等于输入字符串的长度，不会发生任何填充。 可选的 pad_type 参数的可能值为 STR_PAD_RIGHT，STR_PAD_LEFT 或 STR_PAD_BOTH。如果没有指定 pad_type，则假定它是 STR_PAD_RIGHT。
例：$nstr=str_pad($str,20,"@",STR_PAD_BOTH);

Ｇ 
string strtolower(string $str) 本函数将字符串$str全部变为小写；
string strtoupper(string $str) 本函数将字符串$str全部变为大写；
string ucfirst(string $str) 本函数将字符串$str第一个字符变为大写；
string ucwords(string $str) 本函数将字符串$str每个词的第一个字母变为大写；

H 
htmlspecialchars(string $str);将字符串转化为实体（即$str是html或者js代码，用echo 输出其返回值，将不会被浏览器解析，而当字符串输出）；
备注：该函数在留言板中使用；

string addslashes ( string $str )  — 使用反斜线引用字符串；
    返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（'）、双引号（"）、反斜线（\）与 NUL（NULL 字符）。
备注：但默认情况下PHP 指令 magic_quotes_gpc 为 on，就已经对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。

string stripslashes ( string $str ) 反引用一个引用字符串。 即返回一个去除转义反斜线后的字符串（\' 转换为 ' 等等）。双反斜线（\\）被转换为单个反斜线（\）。

string strip_tags ( string $str [, string $allowable_tags ] ) 从字符串中去除 HTML 和 PHP 标记(没有第二个参数表示删除所有标记)，第二个参数为保留标签（即其他标签都删除，保留这里面的）；
例：echo strip_tags($title,'<u><b>');

string nl2br ( string $string [, bool $is_xhtml = true ] ) 在字符串 string 所有新行之前插入 '<br />' 或 '<br>'，并返回。
例：$str="this is a test\n";//这个换行在文件中认，但在浏览器显示时不认；
echo nl2br($str);     //这一步可以将\n变成<br />

*********************
默认情况下，PHP 指令 magic_quotes_gpc为 on，它主要是对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。不要对已经被 magic_quotes_gpc转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc()进行检测;

I 
a   strrev() ;翻转字符串；（好像中文的不适用）
b   strlen();计算字符串长度（返回的是字节数，即utf-8中文一个字抵3个字节）；
c   number_format() ;按千分制（即三位数）格式化数字；
语法：string number_format ( float $number [, int $decimals = 0 ] )
备注：第二个参数为保留的小数位数；
语法：string number_format ( float $number , int $decimals = 0 , string $dec_point = '.' , string $thousands_sep = ',' )
备注：第三个参数为分隔正数与小数符号，第四个参数为分隔每段三位数的符号；
例：
$str=123454555;
echo $str."<br />";
echo number_format($str,2);
echo number_format($str,2,'.',',');

d string md5 ( string $str [, bool $raw_output = false ] ) 加密函数，以 32 字符十六进制数字形式返回散列值。 如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以原始的 16 位二进制格式返回。
备注：设置密码时，最好使用md5加密两次以上；
例：
$str=1234;
echo $str."<br />";
echo md5(md5($str).'neo');

J 比较字符串
a 用等号（==）比较字符串（常见），当然还有!=,这两个是区分大小写（即按照ASC||比较）的；
 注意：如果需要不区分大小写进行比较，则统一将需要比较字符串转化为大写或者小写；

b int strcmp ( string $str1 , string $str2 );二进制安全字符串比较（即将需要比较的字符串中字符转化为ASC||进行大小比较），如果 str1 小于 str2，返回负数；如果 str1 大于 str2，返回正数；二者相等则返回 0。 

c strcasecmp();二进制安全比较字符串（不区分大小写）。和strcmp()一样，只是不区分大小写；

d strnatcmp() 该函数实现了以人类习惯对数字型字符串进行排序的比较算法，即按自然顺序比较；

e strnatcasecmp() 按自然顺序不区分大小写；

备注：以上函数比较后都返回int整数（通常为-1,0,1）

f usort($arr,callback) 对数组元素进行排序；
例：usort($arr,"strnatcmp"); //就可以让数组元素按自然顺序排序；

g 
   string strstr ( string $haystack , mixed $needle [, bool $before_needle = false ] )返回 haystack 字符串从 needle 第一次出现的位置开始到 haystack 结尾的字符串，如果没有needle，则返回false。，如果第三个参数为true，则返回needle之前字符串（不包含needle），该函数区分大小写。如果想要不区分大小写，请使用 stristr()；

  int strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )返回 needle 在 haystack 中首次出现的数字位置，没找到返回false；

  int strrpos ( string $haystack , string $needle [, int $offset = 0 ] )返回字符串 haystack 中 needle 最后一次出现的数字位置，没找到返回false；

h void list ( mixed $varname , mixed $... ) 像 array() 一样，这不是真正的函数，而是语言结构。list()用一步操作给一组变量进行赋值。

j array explode ( string $separator , string $string [, int $limit ] )此函数返回由字符串组成的数组，每个元素都是 string的一个子串，它们被字符串 separator作为边界点分割出来，每个子串不包含separator哦。如果设置了 limit参数，则返回的数组包含最多 limit个元素，而最后那个元素将包含 string的剩余部分。 

k string str_repeat ( string $input , int $multiplier )返回 input 重复 multiplier 次后的结果。 

l 
string implode ( string $glue , array $pieces )用连接符$glue把数组元素拼接在一起；
string implode ( array $pieces ) 没有连接符，直接将数组元素拼接在一起；

m   string dirname ( string $path ) 给出一个包含有指向一个文件的全路径的字符串，本函数返回去掉文件名后的目录名。注意取得的字符串没有最后的/哦；

n   parse_str() 函数把查询字符串解析到变量中。语法：parse_str(string,array)
例：
<?php
parse_str("id=23&name=John%20Adams");
echo $id."<br />";
echo $name;
备注：用& 才能解析；

o  str_replace 字符串替换，语法：mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )
    str_ireplace 不区分大小写的字符串替换；
使用说明：如果 search 和 replace 为数组，那么 str_replace() 将对 subject 做二者的映射替换。如果 replace 的值的个数少于 search 的个数，多余的替换将使用空字符串来进行。如果 search 是一个数组而 replace 是一个字符串，那么 search 中每个元素的替换将始终使用这个字符串。该转换不会改变大小写。
即：这个替换函数操作，完全取决于第二个参数，第二个参数为数组，则和第一个参数一一对应，如果第二个参数数组个数小于第一个数组，则用空字符串和第一个数组对应，如果第二个参数仅为一个字符串，那么第一个参数的全部替换都由这个字符串进行；
例：
$arr=["aaa","bbb","ccc","ddd"];
$newarr = str_replace(["aaa","bbb"],"hehe",$arr);	//不是改变原数组；

p str_repeat — 重复一个字符串
例：
$str ="this is a demo!";
$newstr =  str_repeat($str,3);
echo $newstr;
	
q str_shuffle — 随机打乱一个字符串，和数组shuffle不一样，数组这个是操作本数组，而字符串的str_shuffle则是返回打乱的字符串；

r  str_split — 将字符串转换为数组，规定多少个字母为一组，组成一维或者二维数组；
$str = "Hello Friend";
$arr1 = str_split($str，3);

s str_word_count — 返回字符串中单词的使用情况；如统计 string 中单词的数量；

t  strrchr 查找指定字符在字符串中的最后一次出现，并返回指定字符及后面的字符；此函数与strstr()对应；

u substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）

v  substr_count — 计算字串出现的次数;
   substr_replace — 替换字符串的子串

w  wordwrap — 打断字符串为指定数量的字串


第九章  正则表达式  


1 正则表达式，就是一个匹配“模式”；正则表达式本身就是一个含有一些语法规则的字符串；
  正则表达式一定要在对应的函数中使用；
  作用：用于字符串的模式分隔、匹配、查找及替换工作；
  正则表达式组成：
A
a 定界符号（必需）：多种符号都可以（除了字母，数字和\其他符号基本都行，如// {} ||），常用为// 
b 原子（必需）：最小的一个匹配单位（放在定界符中），在一个正则表达式中，至少要有一个原子；
c 元字符（可选）：元字符不能单独使用，用来修饰原子，扩展和限制原子功能（写在定界符中）；
d 模式修正符号（可选）：对模式（正则）修正，（写在定界符右边）；

B 原子  具体分类
a 普通字符作为原子：如a~z、A~Z、0~9等；

b 一些特殊字符和转义后元字符作为原子：所有标点符号，但语句特殊意义的符号需要转义后才可以作为原子，如：\'  \"  \*  \+  \?  \. 等；

c 一些非打印字符作为原子：如：\f（换页符） \n（回车） \t（tab制表符） \r（换行） \v（垂直制表符）  \cx

d 使用“通用字符类型”作为原子：
例：
\d （代表任意一个数字）                      
\D（代表任意一个非数字） 
\w（代表任意一个字 a~z A~Z 0~9 _ ） 
\W（代表任意一个非字，除a~z A~Z 0~9 _之外所有字符）
\s  （代表空白，包括空格，回车，tab） 
\S（代表任意一个非空白）
\b 匹配单词边界；
\B 匹配不是单词边界；
简记：时不我待(sbwd,SBWD相对于小写就是取反)
猜测(拿不准)：正则表达式中的转义符\，优先转义特殊字符，如 \\{ ,优先转义{,最前面的转义符\，可以看做不存在，但是\\\{，则匹配的是\{；

e  自定义原子表([])作为原子：原子表[]就相当于一个通用字符类型，只不过这里面能匹配内容需要自己定义；'/[^a-zA-Z]/' 就表示匹配（查找）不是a-z且不是A-Z的任意一个内容；^在自定义原子表[]中表示范围取反；如：‘/[apj]sp/’
备注：在原子表中.+?这些不用转义，如[.+?]

f 点(.)作为原子能代表所有的；
**********************************************
正则表达式匹配：总体是按照定界符号中的内容进行匹配，具体内容顺序与被匹配内容不同，都不能匹配，例：'/abc/'去匹配字符串"bca"是不会成功的，'/abc/'中的a就是一个原子，上面的通用匹配字符，也只能代替一个原子去匹配，当然如果需要代替多个，可以用元字符进行功能扩展或者限制；

C 元字符：不能单独使用哦，扩展或限制原子功能；
*  用来修饰其前面的一个原子可以出现0个、1个或多个（任意次），即{0,}
+ 用来修饰其前面的一个原子可以出现1次或多次，不能没有；即{1,}
？用来修饰其前面的一个原子可以出现0次或1次；即{0,1}
{n} 用来修饰其前面的一个原子只能出现n次，多一次和少一次都不行；
{n,m}用来修饰其前面的一个原子出现次数在n次和m次之间（包含n次和m次）
{n,} 用来修饰其前面的一个原子出现至少n次（包含n次）
|  是或的关系，表示它两边的原子，只要有一个出现就可以，但是 | 的优先级是最低的；
例：'/oracle|mysql/' 这个是匹配oracle或者mysql中的一个；

^和\ A （两者作用一样）表示必须以什么开始（有模式修正符m时，目标字符串多行那么每行开头也算，即^也匹配“\n”或“\r”之后的位置），这个必须写正则表达式的最前面；例：'/^abc/'

$或\Z（两者作用相同）表示必须以什么结束（有模式修正符m时，目标字符串多行那么每行结尾也算，即$也匹配“\n”或“\r”之前的位置。），这个必须写在正则表达式的最后面；例:'/abc$/';如果要abc开头，又要abc结尾，则 '/^abc.*abc$/';而'/^abc$/'只能匹配字符串'abc';


（）作用：（默认情况下，括号同时具备以下四种作用）
a 改变优先级别；
b 将小原子变成大原子；
c 子模式，整个表达式是一个大的模式，小括号中是每一个独立的子模式；
理解：在大模式匹配成功的前提下，子模式的作用就是能通过匹配成功后产生的数组，获取到其本身 （）中的匹配内容；
例：
$str='this is a 2015ab-2-5';
$reg="/(\d{4}(ab))-(\d{1,2})-\d{1,2}/";
返回的数组：Array ( [0] => 2015ab-2-5 [1] => 2015ab [2] => ab [3] => 2 ) 
排序：下标0代表整体匹配内容；然后按括号中左(出现先后排序，（先出现，其（）中的匹配内容对应数组的下标就靠前（看上例）；


例：
Array ( [0] => Array ( [0] => 2015-2-5 [1] => 2016/12/12 ) [1] => Array ( [0] => 2015 [1] => 2016 ) [2] => Array ( [0] => - [1] => / ) ) 

d 反向引用：在正则表达式中，后面需要匹配的内容可以是前面子模式已经匹配到的内容，单引号正则表达式中用  \下标（子模式对应下标），双引号正则表达式用  \\下标；
例：
$str='this is a 2015-2-5 sdfdsflsdjfldsjf';
$reg="/(\d{4})(-|\/)(\d{1,2})\\2\d{1,2}/";
结果：Array ( [0] => 2015-2-5 [1] => 2015 [2] => - [3] => 2 ) 
备注：'/(?:\d{4})/'中如果出现(?:        )这种情况，括号就只有a，b功能，不在有子模式和反向引用功能；

D 模式修正符号（单个字符）
a 模式修正符号要写在定界符号外，放在右边；例："/go*gle/i"
b 模式修正符号，一个字符就是一个功能，可以组合使用；例："/go*gle/ieU"
作用：模式修正符号可以修正正则表达式的解释，或者扩充了正则表达式的功能； 
c 具体修正符号
i ：修正正则表达式不区分大小写（默认区分大小写）
m：修正正则表达式把目标字符串本来几行就视为多行，在使用^和$时，每行都适用这两符号；（默认是把目标字符串无论多少行都视为一行）
s：修正正则表达式中的 . 可以匹配换行符号（回车）；当然默认情况（如果没有 s） ，则可以匹配所有除了换行符； 
x：修正正则表达式，可以忽略空白 ，即看做正则表达式是紧凑的，没有任何空白的，如果目标表达式中有空白，则不能被匹配；
例：$str = "web server"; $reg = "/web server/x";结果是不能被匹配；
U：通过U可以进行切换贪婪模式，如果正则表达式是贪婪，则切换为不贪婪，如果原来为不贪婪就切换成贪婪（不建议采用），默认正则表达式为贪婪模式，可以通过(.*?)或者(.+?)解决（建议采用）；
备注：拥有(.*)或者(.+)的正则表达式也是贪婪模式，贪婪是指目标字符串中有多段都能匹配，但正则表达式取最大的一段字符串作为匹配结果；
e ：针对preg_replace()，在参数2中先后向引用，然后进行eval剥离并执行代码，然后替换；

简记：色母系semUxi
备注：以上为常用的模式修正符号，大小写功能不同，请注意；

E 正则表达式的编写
a 正则表达式就是一种语言，要把开发思想放进去
b 列需求；
******
常见的正则表达式，如url，邮箱等，直接百度--常见正则表达式php；

2 正则表达式函数
分隔 、匹配、查找、替换
a 字符串处理函数（处理快，但功能不全）
b 正则表达式函数（功能强大，但效率低）
注意：如果可以使用字符串处理函数处理的字符串，就不要使用正则处理函数处理；
-----匹配查找-------
c preg_match — 执行一个正则表达式匹配
语法：int preg_match ( string $pattern , string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0 ]]] )搜索subject与pattern给定的正则表达式的一个匹配. 
      preg_match()返回pattern的匹配次数. 它的值将是0次(不匹配)或1次, 因为preg_match()在第一次匹配后 将会停止搜索.preg_match_all()不同于此, 它会一直搜索subject直到到达结尾. 如果发生错误preg_match()返回FALSE. 
      第三个参数是一个数组，数组元素值为匹配得到的内容；
      第四个参数值可以是PREG_OFFSET_CAPTURE ，将返回每个匹配内容的相对目标字符串首字符的偏移量；查看参考手册；
      第五个参数，是规定正则表达式从目标字符串哪里开始匹配；
备注：第四个参数值为0，就能不显示偏移来设置第五个参数；

d preg_match_all — 执行一个全局正则表达式匹配
int preg_match_all ( string $pattern , string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )       返回完整匹配次数(可能是0), 或者如果发生错误返回FALSE.     搜索subject中所有匹配pattern给定正则表达式 的匹配结果并且将它们以flag指定顺序输出到matches中. 在第一个匹配找到后, 子序列继续从最后一次匹配位置搜索. 
      除第四个参数外，其余参数与preg_match()一样；
      第四个参数：
PREG_PATTERN_ORDER（默认）：排列数组，第一个子数组为整体内容数组，后面一个子模式为一个子数组，以此类推；
例：
Array
    ([0]=>Array
            (
  [0]=>http://www.baidu.com
  [0]=>http://www.google.com
            )
  [1]=>Array
            (
  [0]=>http
  [1]=>http
            )
)
PREG_SET_ORDER ：排列数组，一个整体匹配内容（包含子模式匹配内容）为一个子数组，以此类推
例：Array
    ([0]=>Array
            (
  [0]=>http://www.baidu.com
  [1]=>http
            )
  [1]=>Array
            (
  [0]=>http://www.google.com
  [1]=>http
            )
)
PREG_OFFSET_CAPTURE ：返回数组中多了一项相对于目标字符串的偏移量


e preg_grep — 返回匹配模式的数组条目（条目不是数目，而是具体的数组元素，本质上是返回满足匹配条件的元素组成的数组）
语法：array preg_grep ( string $pattern , array $input [, int $flags = 0 ] ) 返回给定数组input中与模式pattern匹配的元素组成的数组（即将数组每个元素都拿去匹配，能匹配上的元素保留，最后返回保留元素组成一个数组），第三个参数如果设置为PREG_GREP_INVERT, 这个函数返回输入数组中与 给定模式pattern不匹配的元素组成的数组.
------分割--------
字符串分隔函数：explode()   implode()     

f   preg_split — 通过一个正则表达式分隔字符串
语法：array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )通过一个正则表达式分隔给定字符串. 返回分隔后一个数组（默认数组元素将不会包含分隔符，即正则表达式匹配的内容），第三个参数为限制分隔成几份（无论分隔符子模式匹配内容用不用数组元素显示，都不算在这个份数中），值为-1,0，null都表示不限制，第四个参数：
PREG_SPLIT_NO_EMPTY 如果这个标记被设置, preg_split()将进返回分隔后的非空部分. 
PREG_SPLIT_DELIM_CAPTURE如果这个标记设置了, 用于分隔的模式中的括号表达式将被捕获并返回.即正则表达式子模式匹配到的内容会以数组元素值方式返回；
PREG_SPLIT_OFFSET_CAPTURE 相对于目标字符串的偏移量；

------替换-----
g  字符串替换函数：
str_replace — 字符串替换 
语法：mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )该函数返回一个字符串或者数组（参数3原来是数组则返回数组，原来是字符串就返回字符串）。该字符串或数组是将 subject 中全部的 search 都被 replace 替换之后的结果。
简记：3中2换1，即在参数3中用参数2去替换参数1；参数4为变量，函数进行后该参数被赋值为替换的次数；
说明：前三个参数都可以是字符串或者数组，都是字符串就很简单了，这里不解释了；
情况1：参数1为数组，参数2为字符串，则是在参数3中寻找参数1数组中每个元素值，然后用参数2中字符串去替换；
情况2：参数1为数组，参数2为数组，则是在参数3中寻找参数1数组中每个元素值，然后用参数2数组中与参数1数组中相对应下标的那个元素值去替换，如果参数1数组元素个数大于参数2中数组元素个数，则参数1中数组多出来的元素用空替换，所以最好是元素个数相等；参数2不能单独为数组；
备注：该函数能操作的最复杂情况：前三个参数都是数组，前两个参数数组查找元素和匹配元素是对应好的，然后把参数3数组中每个元素一一替换一遍，然后返回数组；


h  正则替换函数：
preg_replace — 执行一个正则表达式的搜索和替换；
mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] ) 这个函数大部分功能和str_replace()差不多；
值得注意的是，这个函数参数2，可以使用反向引用，参数2最外面是""，则反向引用用\\0(代表匹配的全部内容)  \\1等；如果参数2最外面使用''，则反向引用使用\0 \1（记住是取决于最外面的，而不是里面的，例：'<a href="\1\2.$3$4">\0</a>'  ）；当然在这里的\\和\可以用$代替；
最重要一点：参数2中能反向引用，？？？但其中的符号却不用转义，因为从根本上将，第二个参数不是正则表达式；
 
第二个参数如果有后向引用的要求：
a 不管参数2里面是否已经是字符串，都要用''或者""整体包围；
b 每个子模式得到并不是字符串，也需要用''或者""包围，如'\0',"\1"，如果本身就是取数字，就不加引号了；
*******当然以上两点是针对参数2（替换部分）需要字符串的情况下，如果替换本身就是数字，那就不用加引号了；
c 参数2中除了与本身出现多重引号需要转义外，其余符号并不需要像正则表达式一样转义；
d 正则表达式必须有模式修正符 e ，作用：先获取子模式匹配内容，在参数2中后向引用后，在进行eval函数（剥离字符串中能执行的代码，并执行），把整个结果作为替换内容；
e  反向引用用\\还是\取决于最外围的是""还是''，当然这儿也可以用$;；
备注：模式修正符e已经过期了，建议用preg_replace_callback()
例参数2：
 一      '"<a href=\"\0\">".strtoupper("$0")."</a>"' //****说明：相当于设置模式修正符e，则有将第二个参数去掉最外层引号并执行原引号内代码功能；
二       "'<a href=\'\\0\'>'.strtoupper('\\0').'</a>'"
备注：以上两者作用一样；注意以上用到转义的地方都是和最外围引号重合才转义的，并不是想正则表达式一样；
***顺便记忆一下：字符串必须是单引号或者双引号以及定界符包围的才是（变量本身就赋值时就有，例$str='sdf';），但是切记   asdf   并不是字符串；
备注：preg_replace反向引用功能已经过时了，用preg_replace_callback()代替

i preg_replace_callback()与preg_replace()除了第二个参数可以指定回调函数外，其余一样，自动传入回调函数的实参为一个由匹配值组成的数组（注意：这个数组元素值是正则表达式完成每一次匹配后，与子模式匹配内容组成一维数组,注意是一次匹配成功，就调用回调函数，下一次匹配成功，再次调用），这个正则表达式就不用模式修正符e了；
例：
function myFun($arr){
  return $arr[0];
}
preg_replace_callback("//","myFun",$str);
例：
$sql = "select * from __USER__ JOIN __SCORE__ ON __USER__.id=__SCORE__.id";
$var = 'ws_';
$sql = preg_replace_callback('/__(\w{1,})__/',function ($arr) use ($var){return $var.strtolower($arr[1]);},$sql);
echo $sql;

j  string preg_quote ( string $str [, string $delimiter = NULL ] ) preg_quote()需要参数str并向其中 每个正则表达式语法中的字符前增加一个反斜线. 这通常用于你有一些运行时字符串 需要作为正则表达式进行匹配的时候. 即：$str字符串中所有符号是需要匹配的符号，不是在正则表达式中有特殊意义的；









第十章   调试错误



2 错误类型：a 语法错误（阻止脚本执行）  b 运行时错误（继续进行） c 逻辑错误（不阻止脚本，也不输出错误信息）；
浏览器报告错误：E_ALL , E_NOTICE （小错误，脚本继续执行）,  E_WARNING（中，脚本继续执行） , E_ERROR（脚本无法继续执行）等等；
更改错误报告级别
方式1：php配置文件(php.ini)，搜索error_reporting，找到error_reporting = E_ALL ，可以它更改为error_reporting = E_ALL & ~E_NOTICE;（不建议采用）
方式2：在脚本文件<?php 后面写error_reporting(E_ALL &~ E_NOTICE);(建议采用)

3 自定义错误报告
1  E_ERROR      致命运行错误（阻止脚本运行）
2  E_WARNING    运行时警告
4  E_PARSE      语法解析错误
8  E_NOTICE   运行时注意消息
16   E_CORE_ERROR   php启动时初始化过程中的致命错误
32   E_CORE_WARNING   php启动时初始化过程中的警告（非致命）
64   E_COMPILE_ERROR    编译时致命性错误
128  E_COMPILE_WARNING  编译时警告
256  E_USER_ERROR   用户自定义的致命错误
512  E_USER_WARNING   用户自定义的警告
1024   E_USER_NOTICE    用户自定义的提醒（经常是bug）
2048   E_STRICT     编码标准化警告
6143   E_ALL      所有错误、警告和注意
例：
<?php
  //在php中注册一个函数，来处理错误报告，而不按照原来的方式处理；
  set_error_handler("myErrorFun");
  $mess="";
  function myErrorFun($error_type,$error_message,$error_file,$error_line){
    global $mess;
    $mess.="错误级别类型：{$error_type};&nbsp;&nbsp;错误消息：<b>{$error_message}</b>;&nbsp;错误位置：<font color='red'>{$error_file}</font>,&nbsp;第&nbsp;{$error_line}&nbsp;行；";
  }
    //设置输出错误报告位置
  echo $mess;

4  错误日志默认写到了Web服务器（Apache）的错误日志中；
A  日志管理方式
a 日志默认位置
Apache位置：wamp/logs/apache_error.log

b 把日志写到操作系统：更改php配置文件中   ;error_log=syslog 把前面的;（分号）去掉，则开启；
查看写到操作系统的日志：我的电脑（计算机）-右键-管理-事件查看器-window日志-应用程序；

c （建议采用，最好在脚本操作，不要在配置文件更改）自定义文件作为日志文件：关掉 ;error_log=syslog（即保留前面分号），
开启 error_log = "c:/wamp/logs/php_error.log"（这段代码在 ;error_log=syslog 的下一行）(即去掉前面的分号; 路径可以自己设置)

备注：在脚本中也可以操作php配置文件，ini_set("属性","值") 、ini_get（属性）--获取属性值；
例：ini_set("display_errors","off");
display_errors=off  显不显示错误报告；
log_errors=on           日志文件是否开启（默认开启）；
备注：编写网站注意事项里，有例子；


5 PHP的异常处理（程序本来正常，但出现X因素，如车胎爆了，就要准备备胎）
语法：
try{
  //抛出异常（对象）
  throw new Exception("写出异常");
}catch(Exception $e){
  echo  $e->getMessage()."<br/>";
}
工作原理：试着执行try中代码，如果没有问题，继续执行catch之后的代码，如果有问题，则不再执行try中异常后面的代码，直接执行catch相应异常中的代码，然后再继续执行try catch后面的代码；
Exception 是系统的类；如果有异常对象抛出，就将异常对象给catch( )中的类，try中发生异常位置后的代码不在执行，而是直接到catch中，catch中执行完成后（catch中代码可以用$e->getMessage()来获得抛出异常的对象信息），再继续catch后的执行代码
备注：a try catch是一体的 ，b try catch之间不能有任何代码；
例：
<?php
  set_error_handler("myErrorFun");
  function myErrorFun($error_type,$error_message,$error_file,$error_line){
    if($error_type==E_WARNING){  //这里的E_WARNING可以换成数字2；
      throw new Exception("发生错误：{$error_type},
      //***可以看出throw可以不再try{}里；             {$error_message},在{$error_file},第{$error_line}行；");
    }
  }
  function run($a){
    echo $a;
  }
  try{  
    echo "程序输出了！<br/>";
    run();//注意这儿参数一个WARNING，如果把run()移出try{}，虽然产生同样的                              //错误，但是throw不会抛出异常对象，即错误中携带了在try{}中产生信息
  }catch(Exception $e){
    echo $e->getMessage();
    //这个异常对象$e不仅有throw new Exception(这儿的信息)，而且还有错误代   //码，错误文件位置，错误行号等信息，也可以通过该类其他方法得到
  }

6 自定义异常
A 自定义的异常类，必须是系统类Exception的子类，并且父类的方法（除了构造函数和__toString()）都有关键字final（即不可重名，覆盖）;
B 如果继承Exception类，重写了构造方法，一定要调用一下父类中被覆盖的构造方法（还要记得传参数哦！）
例：
class myException extends Exception{
  function __construct($mess){
    parent::__construct($mess);
  function myRecover(){
    echo "修复代码";
  }
  }
}

7 捕获多个错误
A 理解：try{}产生错误后，throw不会捕获错误（throw没有这功能）再抛出异常对象，throw是代码执行到它，它才会抛出异常对象，并且将代码直接跳转到catch；捕获错误功能函数有默认的，如果自定义的话是set_error_handler("这里自定义函数捕获错误函数名")；

B 一个try可以对应多个catch，catch{}中都还可以写try{}catch{}代码；
try{
  try(){

  }catch(\Exception $e){

  }
}catch(Exception_one $e){
  
}catch(Exception_two $e){
  
}








第十一章   日期和时间

8 时间戳：a 是一个整数 b 是从1970年1月1日（计算机元年）到现在的秒数，但是注意是格林时间；
A  time() 返回时间戳，即秒数
B  date("格式"[,时间]) 格式化时间，如果没有第二个参数，则默认现在的时间戳；
例：
date("Y-m-d H:i:s");//minute不能用m代表了，用的是i；
date("Y/m/d H:i:s");
date("Y年m月d日 H:i:s");
备注：具体格式可以查询配置手册date()；
例：
date("Y")；获得时间戳的年；
date("m")；获得时间戳的月；
date("d")；获得时间戳的日；
date("t")；获得时间戳的这个月有多少天；
date("w")；获得时间戳对应星期几（数字，星期天为0）
备注：这个可以设置第二个参数（通过mktime()），获取特定时间戳的信息；

C 调整为北京时间方法：
a  在脚本中更改：date("Y-m-d H:i:s",(time()+8*60*60));
b  在配置文件中更改：date.timezone = 为date.timezone = "Asia/Shanghai"(或者改为date.timezone = PRC)并去掉前面的分号
c  在脚本中写出代码：date_default_timezone_set("PRC");

9 返回时间戳函数（基本上函数名中有time的，都是返回时间戳）
A  int mktime ([ int $hour [, int $minute [, int $second [, int $month [, int $day [, int $year [, int $is_dst ]]]]]]] )  给出的参数返回 Unix 时间戳。时间戳是一个长整数，包含了从 Unix 纪元（January 1 1970 00:00:00 GMT）到给定时间的秒数。 

B int strtotime ( string $time [, int $now ] )本函数预期接受一个包含   美国英语日期格式   的字符串并尝试将其解析为 Unix 时间戳（自 January 1 1970 00:00:00 GMT 起的秒数），其值相对于 now 参数给出的时间，如果没有提供此参数则用系统当前时间。
备注：返回的是统一相对于格林时间的秒数，如果脚本中设置了时区，先把时间（即第一个参数）换算到格林时间，再计算就行（这是计算思路，程序直接写就行了，不用考虑这个换算）；
例：
date_default_timezone_set("PRC");
echo strtotime("2015/2/8 00:00:00")."<br/>";
备注：这儿返回的时间戳要比格林时间少8*3600秒；

microtime() 返回微秒数；
例：
echo microtime();
0.50575300 1423377330
备注：前一个字符串为微秒，后面为秒，但都是以秒为单位；
例2
echo microtime(true);
1423377404.334
备注：有参数为true，则和在一起表示，则变成毫秒了；





第十二章 文件系统
10 文件类型
在windows下：file、dir、unknown
在unix下：file、dir、block、char、fifo、link、unknown；
了解内容：
block     块设备文件，如某个磁盘分区，软驱，光驱CD-ROM
char    字符设备是指在I/0传输过程中以字符为单位进行传输的设备，如键盘、打印机
dir   目录类型，目录也是文件的一种
fifo    命名管道，常用于将信息从一个进程传输到另一个进程；
file    普通文件类型，如文本文件或可执行文件等；
link    符号链接，是指向文件指针的指针。类似于windows的快捷方式；
unknown   未知类型；
A  文件夹也是文件的一种类型，可以用filetype()获取类型，但用is_file()判断将为false；
filetype()，获取文件类型，返回字符串，如block；
file_exists(),如果由 filename 指定的文件或目录存在则返回 TRUE，否则返回 FALSE。
fileatime()返回文件上次被访问的时间，如果出错则返回 FALSE。注意时间以 Unix 时间戳的方式返回
filectime()返回文件上次 inode 被修改的时间，如果出错则返回 FALSE。时间以 Unix 时间戳的方式返回。inode为索引节点，大致可以理解为文件属性，整个函数粗糙理解为返回创建文件时间；

filemtime()返回文件上次被修改的时间，出错时返回 FALSE。时间以 Unix 时间戳的方式返回
filesize(),获取文件大小，返回字节数，只能返回文件大小，不能返回文件夹大小；
is_dir(),判断文件类型是否为目录，返回布尔值；
is_executable()，判断给定文件是否可以执行，返回布尔值；
is_file()，判断给定文件名是否为一个正常的文件名，返回布尔值；
is_link()，判断给定文件名是否为一个符号链接，返回布尔值；
is_readable()，判断给定文件是否可读，返回布尔值；
is_writable()，判断给定文件是否可写，返回布尔值；


额外知识：表示同级目录下既可以不写目录直接文件名，也可以用 ./文件名  ；
例："./jsq.php"   和  "jsq.php"是一样的；

11
A 跨平台注意事项
a  路径分隔符
windows ：   c:\Appserv\www\aa.php
linux :    /user/local/apache/
备注：常量 DIRECTORY_SEPARATOR 可以适应不同操作系统代表路径分隔符

注意：所有程序中不管是什么操作系统，全部都是使用 / 来代表路径分隔符号（PHP程序中，Apache配置文件中，PHP配置文件中只要有目录的情况，全部使用 /）；
b 目录分隔符
windows 使用 ;
linux 使用 :
备注：常量 PATH_SEPARATOR 可以适应不同操作系统代表目录分隔符
c 换行符
windows  使用 \n \r
linux   使用 \n
备注：常量 PHP_EOL 可以适应不同操作系统代表换行符
B 目录
./  代表当前目录（也可以不写）
../ 代表父级目录
/ 代表根目录；

C 不同的根路径
a 一个是文档根目录（客户端或者js或者css要操作） ，一个是操作系统的根（php操作的）
备注： php操作文件是服务器端的文件；

D 路径解析函数
    string basename ( string $path [, string $suffix ] ) 返回路径中的文件名部分。如果文件名是以 suffix 结束的，那这一部分也会被去掉。
例：echo basename("/www/php.php",".php");

string dirname ( string $path ) 给出一个包含有指向一个文件的全路径的字符串，本函数返回去掉文件名后的目录名。 

mixed pathinfo ( string $path [, int $options ] )
pathinfo() 返回一个关联数组包含有 path的信息。包括以下的数组单元：dirname(目录)，basename（文件名包含后缀名）和 extension（后缀名，前面没有点，只有名字）。 可以通过参数 options指定要返回哪些单元。它们包括：PATHINFO_DIRNAME， PATHINFO_BASENAME和 PATHINFO_EXTENSION。默认是返回全部的单元。如果不是要求取得所有单元，则本函数返回字符串。
 
string realpath ( string $path )  realpath() 扩展所有的符号连接并且处理输入的 path 中的 '/./', '/../' 以及多余的 '/' 并返回规范化后的绝对路径名。返回的路径中没有符号连接，'/./' 或 '/../' 成分。 

12 遍历目录(最开始两个文件当前目录，父级目录分别是 .    ..   ,一定要跳过这两个文件)
A array glob ( string $pattern [, int $flags ] ) 寻找与模式匹配的文件路径，返回包含路径和文件名的数组，$pattern中的*代表替换任意字符任意次数；第二个参数参考参考手册；返回的是路径+文件，采用相对路径；
例：foreach(glob("./新建文件夹/*") as $filename){echo $filename."<br/>";}备注：这个函数遍历文件，不会出现 .  以及  ..

B  resource opendir ( string $path [, resource $context ] ) 打开一个目录句柄，返回资源类型变量

   string readdir ( resource $dir_handle ) — 从目录句柄中读取条目,返回目录中下一个文件的文件名注意：执行到末尾，返回false，且指针不会自动跳转到开头；
说明：读取这个目录下的一层文件名，这个目录下还有文件夹，即还有子文件，是不读取的，特别注意是文件名，如果是文件夹那么就是文件夹名，没有路径，也没有任何 / ;
  
  void closedir ( resource $dir_handle ) 关闭由 dir_handle 指定的目录流。流必须之前被 opendir() 所打开。 

   void rewinddir ( resource $dir_handle )将 dir_handle 指定的目录流重置到目录的开头
备注：A 和 B（几个函数配合）都可以遍历目录；
共同点：参数都是路径（B针对opendir()）
不同点：前者返回包含路径和文件名的数组，后者中（readdir()）返回只有文件名；

linux下统计目录（即文件夹）大小：   exec("du -shm 路径");

C 
float disk_total_space ( string $directory )— 返回一个目录的磁盘总大小（注意是磁盘，不是一个文件）
float disk_free_space ( string $directory )---返回目录中的可用空间
例：echo disk_total_space('d:');

D 获取整个文件夹大小思路：a 文件夹大小其实是文件夹里文件的大小，而文件夹本身图标大小不获取，b 递归遍历文件夹，遇到文件夹就递归，遇到文件就累加大小；注意要把 . 和 ..去掉；
例：
  $size = 0;
  function bianli($path){
    global $size;
    foreach(glob($path."/*") as $value){
      if(is_dir($value)){
        bianli($value);
      }else{
        $size+= filesize($value);
      }
    }
    return $size;
  }
  echo bianli("admin");

13 文件基本操作函数
bool touch ( string $filename [, int $time [, int $atime ]] )如果文件（$filename）不存在，则会被创建。成功时返回 TRUE， 或者在失败时返回 FALSE。后两个看参考手册；
例：touch("./hehe.txt");

bool copy ( string $source , string $dest )将文件从 source 拷贝到 dest。成功时返回 TRUE， 或者在失败时返回 FALSE. 如果目标文件已存在，将会被覆盖
例：copy("./hehehaha.txt","./新建文件夹/neo.txt");

bool rename ( string $oldname , string $newname [, resource $context ] ) 重命名一个文件或目录，主要起移动目的。尝试把 oldname 重命名为 newname。 成功时返回 TRUE， 或者在失败时返回 FALSE. 
例：rename("./hehehaha.txt","neo.php");

bool unlink ( string $filename )删除 filename。和 Unix C 的 unlink() 函数相似。成功时返回 TRUE， 或者在失败时返回 FALSE. 
例：unlink("neo.php");

string file_get_contents ( string $filename [,  bool $use_include_path [, resource $context [, int $offset [, int $maxlen ]]]] ) 将整个文件读入一个字符串，和 file() 一样，只除了 file_get_contents() 把文件读入一个字符串。将在参数 offset 所指定的位置开始读取长度为 maxlen 的内容。如果失败，file_get_contents()将返回 FALSE。（不用打开文件）
例：echo file_get_contents("hehe.txt");

int file_put_contents ( string $filename , string $data [, int $flags [, resource $context ]] )和依次调用 fopen()，fwrite()以及 fclose() 功能一样。 参数 data 可以是数组（但不能为多维数组），这就相当于 file_put_contents($filename, join('', $array)) ，就是把数组连成一个字符串；（不用打开文件，但是这个是覆盖方式相当于fopen($res,"w")）
例：file_put_contents("hehe.txt",$str);

int readfile ( string $filename [, bool $use_include_path [, resource $context ]] )输出一个文件直接输出，不需要使用echo；（不用打开文件）

array file ( string $filename [, int $use_include_path [, resource $context ]] )把整个文件读入一个数组中，文件每一行为数组的元素值；（注意不用打开文件），行与行之间以enter（即代码为\n或者\r）为标准的，并不是文件中看到的换行,如txt文件满多少字后自动换的，这个就算看起来是多行，其实也是一行，\n或\r不显示才说明起作用了，显示在txt文件中，那就是字符串;
例：echo file("hehe.txt")[2];

resource fopen ( string $filename , string $mode [, bool $use_include_path [, resource $zcontext ]] )打开文件或者 URL（相对路径都行）；第二个参数是模式，以下详解,其他的可选参数基本不用了解；（备注：命名规则里以f开头的函数就是要用fopen()打开才能用的函数）
模式：
r   只读方式打开，将文件指针指向文件头。
r+  读写方式打开，将文件指针指向文件头。
//如果采用r+写入，改变指针位置，是可以在指针位置写入（fwrite()）的，但是写入内容会覆盖原有内容；
w 写入方式打开，将文件指针指向文件头并将  文件大小截为零，如果文件不存在则创建之
w+  读写方式打开，将文件指针指向文件头并将  文件大小截为零，如果文件不存在则创建之
a 写入方式打开，将文件指针指向文件末尾，如果文件不存在则尝试创建之（可以追加内容，即使指针用rewind()移动到文件头，追加内容还是在末尾）
a+  读写方式打开，将文件指针指向文件末尾，如果文件不存在则尝试创建之（可以追加内容）
//采用a或者a+写入，无论指针位置如果变化，写入(fwrite())内容只会在末尾补充；
x 基本不用了解
x+  基本不用了解
附加标记
b 除了纯文本文件，其他都适用b ，如：wb；（建议采用）
t 纯文本文件 使用t 如：rt；
备注：这一切功能是fopen()操作的，跟fwrite()关系不大，fwrite仅仅只有写的功能；
例：$res=fopen("hehe.txt","w");
fclose($res);//这样文件就已经被清空了；

bool ftruncate ( resource $handle , int $size )接受文件指针 handle 作为参数，并将文件大小截取为 size。成功时返回 TRUE， 或者在失败时返回 FALSE.

int fwrite ( resource $handle , string $string [, int $length ] ) fwrite() 把 string 的内容写入 文件指针 handle 处。 如果指定了 length，当写入了 length 个字节或者写完了 string以后，写入就会停止；指针随着写入的字符串，也会移动；



string fgetc ( resource $handle ) 一次读一个字符，返回一个包含有一个字符的字符串；

string fgets ( int $handle [, int $length ] )从 handle指向的文件中读取一行（以文件中enter为准）并返回长度最多为 length - 1 字节的字符串。碰到换行符（包括在返回值中）、EOF 或者已经读取了 length - 1 字节后停止（看先碰到那一种情况）。如果没有指定 length，则默认为 1K，或者说 1024 字节（不写，说不准，感觉不像是1K）。
例：var_dump( fgets($res,20));//显示19个字符的字符串；


string fread ( int $handle , int $length ) 从文件指针 handle 读取最多 length 个字节，或者到达EOF 。，读完指定数量字符，指针也移动了相应数目；
例：var_dump( fread($res,5));

int ftell ( resource $handle ) 返回文件指针读/写的位置
int fseek ( resource $handle , int $offset [, int $whence ] )在与 handle关联的文件中设定文件指针位置。新位置从文件头开始以字节数度量，是以 whence指定的位置加上 offset。whence的值定义为
■SEEK_SET - 设定位置等于 offset 字节。
■SEEK_CUR - 设定位置为当前位置加上 offset。
■SEEK_END - 设定位置为文件尾加上 offset。（要移动到文件尾之前的位置，需要给 offset 传递一个负值。）
如果没有指定 whence，默认为 SEEK_SET。 成功则返回 0；否则返回 -1。注意移动到 EOF 之后的位置不算错误。 

bool rewind ( resource $handle )将 handle 的文件位置指针设为文件流的开头。
备注：在写代码时，最好把需要打开的资源系列函数写在一起，成为一个函数；


bool feof ( resource $handle )如果文件指针到了 EOF 或者出错时则返回 TRUE，否则返回一个错误（包括 socket 超时），其它情况则返回 FALSE。

bool fclose ( resource $handle ) 将 handle 指向的文件关闭。 

14 文件锁定机制---作用：防止多个用户同时读取或者写入文件造成过个内容混杂；
bool flock ( int $handle , int $operation [, int &$wouldblock ] )  轻便的咨询文件锁定（所有php程序必须使用同一方式锁定），应用条件：handle必须是一个已经打开的文件指针，即为fopen()返回值；
operation的值：
■ 要取得共享锁定（读取的程序），将 operation 设为 LOCK_SH ；
■ 要取得独占锁定（写入的程序），将 operation 设为 LOCK_EX；
■ 要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN；
■ 如果不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB；
备注：需要读取的时候用flock($res,LOCK_SH)打开，读完后还要用flock($res,LOCK_UN)释放 ;写入也一样；还有一点，为了防止堵塞，采用LOCK_NB，例：
$res=fopen("hehe.txt","r");
flock($res,LOCK_SH+LOCK_NB);
$nstr=fread($res,1024);
flock($res,LOCK_UN+LOCK_NB);
备注：注意关闭中也有LOCK_NB 哦；





15 文件上传设置
A 表单上传注意：
a 文件上传方式必须是post。（必须）
b 添加enctype="multipart/form-data"    （必须）
例：<form action="upload.php" method="post" enctype="multipart/form-data">
c 设置隐藏表单（可选），这个只是提醒作用，不能杜绝；
例：
<input type="hidden" name="MAX_FILE_SIZE" value="1000000" /> 
 //(隐藏表单)，注意其位置必须写在下面一行代码的上面，还有name必须是MAX_FILE_SIZE;
选择文件：<input type="file" name="myfile" />
备注：以上代码作用当用户上传文件尺寸超过为1M时，将会提示用户；

B PHP配置文件与上传有关的选项
指令名       默认值 功能描述
file_uploads    ON  是否开启文件上传
upload_max_filesize   2M  限制PHP处理文件上传文件大小的最大值，此值必须小于          post_max_size;
post_max_size   8M  限制post方法可以接收信息的最大值；就是整个post请            求的提交值，此值必须大于upload_max_filesize
upload_tmp_dir    NULL  上传文件存放的临时路径，可以是绝对路径，默认NULL            是使用系统的临时目录；
备注：如果上传数据类型有文件，则文件信息是传给全局数组$_FILES，其余信息是传给$_POST;
$_FILES数组为一个二位数组
Array
(
  [TAGname]=>Array    //TAGname是<input >标签中name值；
      (
    [name]=>上传文件名，如123.jpg
    [type]  =>上传文件类型，如 image/jpeg，如果直接放在新名字后面是不行的
      //可以用['name']用pathinfo()取出类型；
    [tmp_name]=>上传文件临时目录（包含文件名）如：c:\wamp\123.tmp
        //特别注意后缀名为tmp，并不是上传时的类型；
    [error]  =>上传过程中产生的错误（0为正常）如：0
    [size]    =>上传文件大小，如：1024
       )
  
)

16文件上传处理(上传文件本质是移动，把文件从客户端移动到服务器，通过表单，再从临时文件目录移动到指定目录，通过函数move_uploaded_file(),用法跟rename()差不多
备注：上传文件时，move_uploaded_file(old_addr,new_addr)移动文件中，new_addr是相对于盘符的地址，而网页读取文件时，如<img src='这里是相对于网站根目录的地址' />；

A 对上传文件进行判断和预处理
第一步：判断错误
值为0：表示没有发生任何错误；
值为1：表示上传文件的大小超出了约定值（默认2M）；
值为2：表示上传文件大小超出了HTML表单隐藏域属性的MAX_FILE_SIZE元素所指定的最大值；
值为3：表示文件只被部分上传；
值为4：表示没有上传任何文件；
值为6：表示找不到临时文件夹；
值为7：表示文件写入失败；
例：if($_FILES['pic']['error'] = 0){}

第二步：判断类型（在Apache配置文件，wamp/bin/apache/Apache2.4.4/conf/mime.types里，但是没搞懂？），可以用下面方式简单判断，
a 取出$_FILES[]['name']的后缀名，用pathinfo($_FILES[]['name'],PATHINFO_EXTENSION)取出，
b 在设置允许文件类型的文件名数组
c 用in_array()判断；


第三步：判断大小
a 获取$_FILES[]['size']，与设置大小比较；

第四步：上传后的文件名一定要设置（一定要设置随机文件名）
a 利用下面B 中move_uploaded_file()复制时需要新的名字，把这个新的名字设为为date()+rand()+文件类型；

B 将临时目录下的上传的文件，复制到我指定目录下，指定的名字就可以完成上传，但是这儿不用rename()函数，而是用：
bool move_uploaded_file( string $filename , string $destination )本函数检查并确保由 filename指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 destination 指定的文件。这里的第一个参数$filename为$_FILES['TAGname']['tmp_name']，其中TAGname是<input >标签中name值；

bool mkdir ( string $pathname [, int $mode [, bool $recursive [, resource $context ]]] ) 新建目录
例：
 function createFolder($path)
 {
  if (!file_exists($path))
  {
   mkdir(dirname($path), 0777);
  }
 }
createFolder("aa/bb/cc/dd/ee");

rmdir() 删除目录，条件是该目录必须为空；

额外知识：辨别用户是否真的上传文件，如果用户真有点击  浏览 选择文件上传，那么$_FILES[TAGname]（即value值）是一个数组，不是一个字符串；如果用户没有上传文件即提交，$_FILES[TAGname]['error']是有错误的，不会等于0，则可以通过if($_FILES[TAGname]['error']==0){真正提交执行代码;} 


17 多个文件上传
A 参考：可以js或者flash的插件，直接可以多个文件上传）(采用）

A 客户端要求，多写<input type="file" name="userfile[]" value="" />
备注：这个操作感觉上有点怪，但必须记住name="userfile[]"，而且这样做的好处是用$_FILES[][][]获取某个文件属性时，可以在上传单个文件的基础上，代码执行添加最后一个下标，前两个下标可以不用变化，利用for循环就可以完成上传文件处理;
备注：复选框的name属性也要采用name="name[]"形式；
得到的数组：
array (size=1)
  'userfile' =>     //这儿就是表单域，即input 的name值，如果没有文件上传，则为空
    array (size=5)
    
        'name' =>     //这个name是不会变的，就name；
          array (size=2)
            0 => string 'QQ图片20140618154111.jpg' (length=24)
            1 => string 'QQ图片20140618154139.jpg' (length=24)
        'type' => 
          array (size=2)
            0 => string 'image/jpeg' (length=10)
            1 => string 'image/jpeg' (length=10)
        'tmp_name' => 
          array (size=2)
            0 => string 'D:\wamp\tmp\php98D8.tmp' (length=23)
            1 => string 'D:\wamp\tmp\php98E8.tmp' (length=23)
        'error' => 
          array (size=2)
            0 => int 0
            1 => int 0
        'size' => 
          array (size=2)
            0 => int 104849
            1 => int 107100
备注：网上下载文件上传类，类是一系列功能的集合；

18 文件下载
情况分类：
A 下载浏览器不能解析的文件，链接直接是指向文件；
B 下载浏览器能解析的文件（如：图片，文本txt，html文件，php文件等）
a 需要把链接设置指向php文件。
b 在php文件中利用header()函数设置头信息；（可以有多个header()函数，header()函数之前不能有任何输出）
c 利用readfile()函数输出用户本来下载的文件；
例：
//设置下载文件地址
$filename = "view.html";
//设置类型（可选）
header("Content-type:text/html"); //很多时候还有charset:utf-8;
//设置第二个参数文件为附件(必写),告诉浏览器以附件方式准备接受数据；
header("Content-Disposition:attachment;filename={$filename}");//注意filename后面是=哦！
//设置大小（可选）
header("Content-Length:".filesize($filesize));
//将文件内容全部输出（必写）
readfile($filename);

备注：以上代码起到一个在浏览器和被下载文件间转接作用




第十三章  GD库使用（PHP的扩展库，其实ImageMagick库比前者还要强大）
GD库作用：统计图，验证码，水印，图片缩放，图片翻转，图片剪切；
GD库在linux下需要单独安装；
必须学习ImageMagick;

19 画图步骤
A 
//a创建资源（设置画布大小）
$im=imagecreatetruecolor(400,400);
//b 设置绘画颜色
  $white=imagecolorallocate($im,255,255,255);
  $red=imagecolorallocate($im,255,0,0);
  $blue=imagecolorallocate($im,0,0,255);
  imagefill($im,100,100,$white);//填充背景颜色

//B 画出各种图形，或写字（画字）
  imageline($im,100,100,200,200,$blue);
//C 保存，或输出给浏览器（功能二选一），写imagepng()等函数的第二个参数就是保存，不写就是输出给浏览器；一定注意输出给浏览器，需要用<img src="" />接收哦；
  header("contents-type:image/gif");//可选，猜测后面image/gif类型好像也没影响，不过还是最好和后面函数imagegif对应吧，如果png就用imagepng();
  imagegif($im);//还有imagepng(),imagejpeg()
//D 释放资源；
  imagedestroy($im);

备注：以上A B C D顺序不能更改；特别注意一点，浏览器不能直接访问这个输出绘画的PHP文件，需要用html标签<img src=".php" />才能输出，且画图的php文件与显示的文件，如html要分成两个文件，即画图php代码单独一个文件，并且该文件不能为utf-8，可以为ANSI；

不用记
//创建资源
imagegif() 以 GIF 格式将图像输出到浏览器或文件
imagedestroy();销毁一图像
imagesetpixel() 画一个单一像素
imageline() 画一条线段
imagerectangle()画一个矩形
imagefilledreactangle()画一矩形并填充
imageellipse()画一个椭圆
imagefilledellipse()画一个椭圆并填充
imagearc()画椭圆弧
imagefilledarc()画椭圆弧并填充
//画字符串
imagestring()水平地画一行字符串
imagestringup()垂直向上地画一行字符串
//画一个字符
imagechar()水平地画一个字符
imagecharup()垂直地画一个字符
imagettftext()用 TrueType 字体向图像写入文本（有点任何角度写入字符串味道）
sin()
cos()
pi()

20 验证码：给人看的，不是给机器看的；防止他人用程序大量注册和大量登录（在网上可以找验证码类）；
 A 设计验证码步骤：
a 类有产生验证码功能（包含验证码尺寸，内容）
b 获取验证码，存储session功能
c 输出到用户功能

B    GD库不同版本可能支持不同函数，以下为解决方案
//哪个函数存在，就用哪个函数输出（其中function_exists("imagegif")与代码：imagetypes() & IMG_PNG 作用一样）
if (function_exists("imagegif")) {
    header("Content-type: image/gif");
    imagegif($im);
} elseif (function_exists("imagejpeg")) {
    header("Content-type: image/jpeg");
    imagejpeg($im, "", 0.5);
} elseif (function_exists("imagepng")) {
    header("Content-type: image/png");
    imagepng($im);
} elseif (function_exists("imagewbmp")) {
    header("Content-type: image/vnd.wap.wbmp");
    imagewbmp($im);
} else {
    die("No image support in this PHP server");
}

21 已有图片处理：跟画图的步骤一样，只是第一步，采用imagecreatefrompng()等类型函数打开资源；
 创建资源
imagecreatefrompng()--从 PNG 文件或 URL 新建一图像
imagecreatefromgif — 从 GIF 文件或 URL 新建一图像
imagecreatefromjpeg — 从 JPEG 文件或 URL 新建一图像
getimagesize() 取得图像大小，返回的是一个数组，索引0,1,2分别对应图片宽、高、类型（这个也是数字 1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM。）
imagesx()取得图像宽度
imagesy()取得图像高度
A 例：添加水印(不太正宗)
  function shuiyin($filename,$string){
    //获取图片的高度，宽度，类型
    list($width,$height,$type)=getimagesize($filename);
    $types=[1=>"gif",2=>"jpeg",3=>"png"];
    $imagecreate="imagecreatefrom".$types[$type];
    //创建资源
    $im=$imagecreate($filename);
    $red=imagecolorallocate($im,255,0,0);
    //画出字符串
    $x=$width/2-(strlen($string)*imagefontwidth(5)/2);
    $y=$height/2-imagefontheight(5)/2;
    imagestring($im,5,$x,$y,$string,$red);
    //保存图片资源
    $save="image".$types[$type];
    $save($im);
    //关闭资源
    imagedestroy($im);
  }
备注：上面为文字水印，且还没有设置重影啊之类的，如果要用图片作为水印，需要imagecopy()函数，具体可以看参考手册；
B 图片压缩或剪切
imagecopyresampled();这个函数既提供剪切功能又有缩放功能，只不过目标图片宽高和源图片剪切宽高相同；（这个函数的参考手册中还有按比例缩放代码）
例：
  function jianqie($filename,$newwidth,$newheight,$swidth,$sheight){
    //获取图片的高度，宽度，类型
    list($width,$height,$type)=getimagesize($filename);
    $types=[1=>"gif",2=>"jpeg",3=>"png"];
    $imagecreate="imagecreatefrom".$types[$type];
    //创建源图片资源
    $im=$imagecreate($filename);
    //创建新图片资源
    $newim=imagecreatetruecolor($width,$height);
    //剪切
    imagecopyresampled($newim,$im,0,0,0,0,$newwidth,$newheight,$swidth,$sheight);
    //保存图片资源
    $save="image".$types[$type];
    $save($newim);
    //关闭资源
    imagedestroy($im);
    imagedestroy($newim);
  }

C 图片的旋转
a 旋转利用imagerotate()函数；
imagerotate()---用给定角度旋转图像，这个函数返回的也是资源（打开的资源都要关闭）；

D 图片的翻转
a 利用imagecopy()，如果是水平翻转，打开图片资源，创建另一个图片资源（尺寸和前面的图片资源一样）则把宽度为1px的不断移到另一个图片资源的相对边（即左边的移到右边），垂直翻转也类似；
其实imagecopyresampled()这个函数也能完成，不过相对于imagecopy()多了两个目标图片尺寸参数，要更复杂一些，因为翻转不涉及图片大小的压缩，所以直接用imagecopy()；

imagecopy()，imagecopyresampled()两个函数的区别：前者被图像拷贝部分不能改变大小，后者可以；
例：
function fanzhuan($filename){
  //获取图片的高度，宽度，类型
  list($width,$height,$type)=getimagesize($filename);
  $types=[1=>"gif",2=>"jpeg",3=>"png"];
  $imagecreate="imagecreatefrom".$types[$type];
  //创建源图片资源
  $im=$imagecreate($filename);
  //创建目标资源
  $newim=imagecreatetruecolor($width,$height);
  //翻转图片
  for($i=0;$i<$width;$i++){
    imagecopy($newim,$im,$width-$i-1,0,$i,0,1,$height);
  }
  //保存图片资源
  $save="image".$types[$type];
  $save($newim);
  //关闭资源
  imagedestroy($im);
  imagedestroy($newim);
}
备注：真正用翻转，缩放功能时，直接用高老师那个类就行；





第十四章  数据库
22 mysql常用知识
A 环境变量：操作系统运行环境的一些参数，如：临时文件夹和系统文件夹；
windows设置环境变量方式：计算机-右键-属性-高级系统设置-环境变量-path（如果没有就添加）-设置路径；

B 在连接之前还要检查数据库软件是否开启，用代码：netstat -a     查看有没有3306端口，如果有就开启了数据库软件了，就可以连接；
a 连接数据库命令
···>mysql -h 主机  -uroot(默认是管理员)  -p（密码）
备注：如果先以默认用户进入了，还要用exit或者\q或者quit退出后再用以上代码以管理员身份进入；

b 查看数据库状态
···>\s

c 查看数据库用户
mysql>select * from mysql.user;     /*mysql为一个库，user为一个内容为用户信息的表*/

备注：要把其他数据库用户全部删除，给root用户名设置密码；
详情参照：http://www.cnblogs.com/fly1988happy/archive/2011/12/15/2288554.html


23 phpmyadmin ：安装在服务器端操作数据库的软件，用户可以通过浏览器直接操作数据库；

24 统一编码 utf-8 ，但不要通过mysq_query('set names utf8');设置，这样代码会冗余，只要文本编辑器使用的是utf-8，数据库使用utf-8就算统一编码了；


25 数据的传递
a 浏览器到数据库，利用全局数组$_GET或者$_POST嵌入insert into tbl_name  values (null,'{$_GET['name']}','{$_GET['sex']}')将数据插入数据库；
特别注意：如果insert，delete，update，select语句（即增删改查）中用到全局数组（$_POST[]或者$_GET[]），而语句又是作为mysql_query()参数，那么语句被双引号包裹（因为双引号中{$_POST[]}类型的变量才能被解析），而{$_POST[]}变量本身必须被单引号包裹，因为把全部的值转化为字符串进行（不管表字段的类型时int还是其他，会自动转化），；

b 数据库到浏览器，利用mysql_fetch_array()等函数返回数组可以嵌入hmtl完成；

*********MYSQL系列函数简单说明**********
A resource mysql_connect ([ string $server [, string $username [, string $password [, bool $new_link [, int $client_flags ]]]]] )

功能：打开或重复使用一个到 MySQL 服务器的连接。

A bool mysql_select_db ( string $database_name [, resource $ link_identifier  ] )

功能：选择 MySQL 数据库


B bool mysql_close ([ resource $link_identifier ] )
 
功能：关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。 
通常不需要使用 mysql_close()，因为已打开的非持久连接会在脚本执行完毕后自动关闭。参见释放资源。 

C resource mysql_query ( string $query [, resource $link_identifier ] )

功能：mysql_query() 仅对 SELECT，SHOW，EXPLAIN 或 DESCRIBE 语句返回一个资源标识符，如果查询执行不正确则返回 FALSE。
对于其它类型的 SQL 语句，mysql_query() 在执行成功时返回 TRUE，出错时返回 FALSE。
非 FALSE 的返回值意味着查询是合法的并能够被服务器执行。这并不说明任何有关影响到的或返回的行数。很有可能一条查询执行成功了但并未影响到或并未返回任何行。

D array mysql_fetch_array ( resource $result [, int $ result_type  ] )

功能：返回根据从结果集取得的行生成的数组，如果没有更多行则返回 FALSE。有一点很重要必须指出，用 mysql_fetch_array() 并不明显 比用 mysql_fetch_row() 慢，而且还提供了明显更多的值。
可选的第二个参数 result_type 是一个常量，可以接受以下值：MYSQL_ASSOC，MYSQL_NUM 和 MYSQL_BOTH(默认)。

备注：虽然mysql_fetch_array()、mysql_fetch_assoc()、mysql_fetch_row()只取一行数据，但是即使去所有数据也用这些函数，因为这些函数比mysql_result()性能更高；
例：
$res = $this->query($sql);
if ($res !== false)
{
    $arr = array();
    /*一直循环到数据取完*/
    while ($row = mysql_fetch_assoc($res))
    {
        $arr[] = $row;
    }

    return $arr;
}
特别注意：除了获取结果集函数用的是结果集资源为参数，其他的函数都是以链接资源为参数；


E int mysql_affected_rows ([ resource $link_identifier ] )
功能：取得最近一次与 link_identifier 关联的 INSERT，UPDATE 或 DELETE 查询所影响的记录行数。
注意：操作的实参是返回的链接资源，不是结果集资源；

F int mysql_errno ([ resource $link_identifier ] )
功能：返回上一个 MySQL 函数的错误号码，如果没有出错则返回 0（零）。

G string mysql_error ([ resource $link_identifier ] )
功能：返回上一个 MySQL 函数的错误文本，如果没有出错则返回 ''（空字符串）。如果没有指定连接资源号，则使用上一个成功打开的连接从 MySQL 服务器提取错误信息
注意：F和G 都是返回最近一次的错误，所以要确保上一次没错，才能看出这一次是否出错；

H int mysql_insert_id ([ resource $link_identifier ] )
功能：返回给定的 link_identifier 中上一步 INSERT 查询中产生的 AUTO_INCREMENT 的 ID 号。如果没有指定 link_identifier，则使用上一个打开的连接。 
如果上一查询没有产生 AUTO_INCREMENT 的值，则 mysql_insert_id() 返回 0。如果需要保存该值以后使用，要确保在产生了值的查询之后立即调用 mysql_insert_id()。

整体例：
<?php
  $mysql_res = mysql_connect('localhost:3306','root','123456');
  mysql_select_db('fi',$mysql_res);
  $sql = "select * from fi_admin_user";
  $result = mysql_query($sql);
  if ($result !== false)
  {
    while ($row = mysql_fetch_assoc($result))
    {
      $rows[] = $row;
    }

  }
  var_dump($rows);









26 分页
主要原理：
a 利用select语句中limit m,n 取某一部分一定数量的记录进行显示；
b 利用链接中的href传递参数如 ?page=页数，利用全局数组$_GET['page']获得，来决定显示哪页；

分页类使用步骤：
a 加载分页类，连接数据库，选择默认数据库
b 获取总记录数（创建分页对象需要，特别注意select返回的是资源）
c 创建分页对象
d 获取记录，特别注意select语句中有{$page->limit}，有点没搞懂limit分明是私有属性，不知道为什么可以引用；例：$sql = "select * from class2 order by id  {$page->limit}";
e 操作返回记录
f 使用fpage()方法， 获取分页内容

额外知识：获得当前网页的Uri 即地址，用$_SERVER['REQUEST_URI'] 得到；
mysql的select语句永远返回的是资源（包括select count(*) from class）；
http_build_query() 生成 URL-encode 之后的请求字符串 ；
parse_str()本函数将一个含有key1=value1&key2=value2类型的字符串解析为变量；
parse_url()本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分
compact()  将变量变为数组
extract()  将关联数组转化为变量
list()     将索引数组变为变量，主要用法
explode()  将字符串变为数组
preg_split() 将字符串变为数组
str_split()  将字符串变为数组
implode()  将数组变为字符串
parse_str()  将'name=neo&age=12'类型字符串变为变量，如果有第二个参数，将转化为数组，存在第二个参数中
http_build_query() 将数组转化为'name=neo&age=12'类型字符串

27 实际模块
a 将模块功能分类，成为不同文件夹（功能由大到小，形成分支结构）
b 编写共用的配置文件；

额外知识：
a html标签可以直接写在php文件中，但位置要在<?php ?>之外（除非用echo 把标签作为字符串输出）；
b <?php include "header.php"; ?> 作用相当于在这条代码的位置引入文件header.php的代码，php代码还是在<?php ?>里，html标签还是在<?php ?>外；

c {$a}这种变量只要在双引号中才能被解析；
d <td colspan="7">标签中属性是colspan不是cols;cols用在<textarea cols=3></textarea>
e 删除前弹出确认框 <a href="list.php?action=del&id=1" onclick="return confirm('您确定删除{$bookname}吗')" >删除</a>
f 删除前弹出确认框 <form action="list.php?action=del" method="post" onsubmit="return confirm('您确定删除这些图书吗？')" >
g 字符串中有变量，最外围用双引号，变量外的第一层也用双引号转义包裹；
h 同时删除多条记录原理
  h.1 利用复选框进行表单提交
  h.2 利用<input type="checkbox" name="id[]" value='.$id.'/></td>';
  h.3 如果表单提交方式为post（get也行），则提交后，$_POST['id']也是一个数组，由选中提交的选项组成，$_POST['id'][0],$_POST['id'][1],$_POST['id'][2]···分别对应选中复选框中第一，二，三中的value值；
  h.4 再用implode结合数组，然后插入sql语句，进行删除；如：$sql="delete from books where id in (".implode($_POST['id'],',').")";
  

28 文件上传类和图片处理类使用步骤
A 文件上传类步骤
a 创建文件上传类对象；
b 利用set()方法设置保存文件路径；
c 利用upload($name)方法上传文件,为上传文件<input type="file" name="这个" value="" />中的name值；
d 在利用其它方法获得信息；

B 图片处理类步骤
a 创建处理类对象，并初始化图片保存路径；
b 然后调用缩放、剪切或者加水印方法实现所需功能，注意：这个函数不是去操作某个文件夹下的图片（体现在没有指明路径上），而是在上传时对图片操作，所以不需要图片原路径，只需要上传后由上传文件类中getFileName()方法产生的新名字就行；

额外知识：
a 删除文件方法 unlink('路径+文件');
b 已经设置header("Content-Type:text/html;charset=utf-8");数据库也是utf8格式，但是还是出现乱码，可能是php文件本身不是utf-8格式，更改文件编码格式：
方法1：通过在dreamweaver中打开这个:文件，然后打开菜单栏的【修改-页面属性】在弹出的窗口里面选择【标题/编码】，选择成为你需要的UTF-8，保存就可以了
方法2：打开文件-另存为-弹出对话框中可以选择编码格式，选择utf-8即可；



29 搜索
A  查询条件写成数组形式，再组合成字符串；
例：
  //start 处理表单上传信息 
  $where="";
  if(isset($_GET['search_submit'])){
    //获取查询条件，放在数组里；
    $where =array();
    if(!empty($_GET['bookname'])){
      $where[] = "bookname like '%{$_GET['bookname']}%'";
    }
    if(!empty($_GET['author'])){
      $where[] = "author like '%{$_GET['author']}%'";
      
    }
    //价格就不用模糊查询了；
    if(!empty($_GET['minprice'])){
      $where[] = "price >= '{$_GET['minprice']}'";
    }
    if(!empty($_GET['maxprice'])){
      $where[] = "price <='{$_GET['maxprice']}'";
    }
    //如果没有搜索条件，则把$where变成空字符串，不为空，则把搜索条件用and连接；
    if(empty($where)){
      $where="";
    }else{
      $where ="where ".implode($where,' and ');
      
    }
    echo $where."进来没";
  }
  //end 处理表单上传信息
  ···
  $sql = "select count(*) from books {$where}";
  ···
  $sql = "select id,bookname,publisher,author,price,ptime from books {$where} order by id {$page->limit}";
备注：以上代码可以实现多检索条件搜索；


B 点击下一页，如果搜索状态不在，可以利用分页类，创建对象时，对参数$query赋值来实现，作用是为向目标页面传递参数,可以是数组，也可以是查询字符串格式，可能使用情况：搜索网页时点击下一页搜索条件数据可能丢失，所以$query可以被$_POST或者$_GET赋值，也可以用http_build_query($_POST)形成字符串来赋值;

C 点击删除时，搜索状态不在，利用删除时标签<a href="">中链接携带信息，把搜索信息加入链接中，如：<a '."onclick='return confirm(\"您确定删除{$bookname}吗?\")'".' href="list.php?action=del&id='.$id.'&page='.$page->page.'&search_submit=1&bookname='.$_GET['bookname'].'&author='.$_GET['author'].'&minprice='.$_GET['minprice'].'&maxprice='.$_GET['maxprice'].'">删除</a>     让目标网页在搜索一次；


30 PDO 数据库抽象层(PHP Data Object) ：利用驱动原则，并不需要相应的数据扩展，而是在php扩展里装相应数据库的驱动；PDO相对于mysql扩展都是优势；

使用PDO 的两个条件：
a php程序里安装PDO扩展（说明PDO扩展函数可以用）；用phpinfo()查看
b 根据操作数据库类型，安装相应数据库驱动，在php配置文件中可以开启与;extension=php_pdo_mysql.dll的驱动；
备注：linux下安装还要学···

31 PDO类
A    类 PDO    
a  创建PDO对象，语法：$pdo = new PDO ( string $dsn [, string $username [, string $password [, array $driver_options ]]] );
说明：DSN（Data Source Name 数据源名称），$dsn包括：具体的数据库驱动、主机、数据库（db_name，不是数据库系统）等；$usename为用户名，$password为密码，$driver_options为设置PDO类的属性（常量）的一个数组，功能相当于setAttribute()；
例：$pdo = new PDO("mysql:host=localhost;dbname=bookstore","root","123456",[PDO::ATTR_AUTOCOMMIT=>false,PDO::ATTR_PERSISTENT=>1]);(不常用)

b 具体哪个库的驱动$dsn具体写法，在php参考手册-函数参考-数据库扩展-数据库抽象层-PDO-PDO Drivers- / MySQL   (PDO) -PDO_MYSQL DSN       /后面为针对mysql的写法；其他库也在PDO Drivers下；
例：
try{
  $pdo = new PDO("mysql:host=localhost;dbname=bookstore","root","123456");
}catch(PDOException $e){
  echo "数据库连接失败：".$e->getMessage();
}
echo "创建PDO对象成功";

c PDO类的属性都是常量（查看常量位置在PDO-预定义常量），利用$pdo->getAttribute()才能获取;
例：
  echo "<br>PDO是否关闭自动提交功能：". $pdo->getAttribute(PDO::ATTR_AUTOCOMMIT);
  echo "<br>当前PDO的错误处理的模式：". $pdo->getAttribute(PDO::ATTR_ERRMODE); 
  echo "<br>表字段字符的大小写转换： ". $pdo->getAttribute(PDO::ATTR_CASE); 
  echo "<br>与连接状态相关特有信息： ". $pdo->getAttribute(PDO::ATTR_CONNECTION_STATUS); 
  echo "<br>空字符串转换为SQL的null：". $pdo->getAttribute(PDO::ATTR_ORACLE_NULLS); 
  echo "<br>应用程序提前获取数据大小（是否持久连接）：".$pdo->getAttribute(PDO::ATTR_PERSISTENT); 
  echo "<br>与数据库特有的服务器信息：".$pdo->getAttribute(PDO::ATTR_SERVER_INFO); 
  echo "<br>数据库服务器版本号信息：". $pdo->getAttribute(PDO::ATTR_SERVER_VERSION);
  echo "<br>数据库客户端版本号信息：". $pdo->getAttribute(PDO::ATTR_CLIENT_VERSION); 
备注：常量信息引用前面是类::  而方法前面是对象哦；

d PDO类的属性都是常量，利用$pdo->setAttribute()才能设置;
例：$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, false);
备注：设置状态为1或0 跟 true和false一样的；


e PDO错误处理  （php参考手册中 PDO-PDO-PDO::setAttribute中PDO::ATTR_ERRMODE）

e.1  默认的错误模式（不提示，我们看不到问题）$pdo->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_SILENT);当然第二个参数也可以为0；
  部分函数，配合默认错误模式的（以下三个函数被常用异常模式中getMessage()取代）
  exec()   执行sql语句，返回成功插入、更改和删除影响行数，如果是查询（无论是否成功）或者语句出现错误，返回0；
  errorCode() 猜测：返回错误代码编号；
  errorinfo()  返回错误信息数组，不需要参数；
e.2  警告模式   $pdo->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING);当然第二个参数也可以为1；
说明：这种模式就跟php出错在浏览器中显示一样的；

e.3  异常模式（采用）  $pdo->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);当然第二个参数也可以为2；
例：
  try{
    //步骤1：创建$pdo对象
    $pdo = new PDO("mysql:host=localhost;dbname=bookstore","root","123456");
    //步骤2：设置为异常处理模式；
    $pdo->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);
  }catch(PDOException $e){
    echo "数据库连接失败：".$e->getMessage();
    exit;
  }
  
  try{
    //使用PDO中方法执行的语句

  }catch(PDOException $e){
    //$e->getMessage()需要输出
    echo "错误".$e->getMessage();
  }

f  PDO处理SQL语句两个方法
f.1 exec()  用来处理非结果集的语句 ，如insert 、update、delete、create ···；这个函数返回影响行数（但select执行成功,不会有影响行数，返回也是0）；如果是插入语句可以用 lastinsertid() 来获取最后插入记录的id；例：echo $pdo->lastinsertid();

f.2 query() 用来处理有结果集的语句，如select、desc、show ；返回PDOStatemen 类的对象，再通过这个类对象的方法，获取结果集，也可以通过foreach()遍历这个对象来获取结果（不建议）；

备注：其实以上两个函数全部sql语句都能执行，都能作用到数据库，判断采用哪个方法的依据是我们需要得到什么结果，如果需要得到影响行数，就用exec()，如果需要得到结果集数据，就用query()，如果两个都不想得到，像 set names utf8 语句两个函数都行；


g PDO针对数据库 事务处理：多条sql语句看做一件事，全部sql语句都执行成功，这件事才成功，如果有任何一条语句出错，就回滚；
前提条件：数据库表存储引擎为innodb（创建表默认的）  和bdb（不建议），mysiam不支持事务；
PDO处理事务步骤：
g.1  利用$pdo->beginTransaction(void)  开启事务，并且这个函数同时有在开启事务点  关闭自动提交功能，还有在调用$pdo->commit(void)或者$pdo->rollBack(void)方法后，自动开启 自动提交功能；
g.2  写好操作数据是否成功的判断，成功执行$pdo->commit(void)，失败执行$pdo->rollBack(void);
g.3  最好在catch(PDOException $e){$pdo->rollBack(void);} 也写上回滚，因为这样整个PDO有任何错误，也回滚；
例：
            ·····
  try{
    //使用PDO中方法执行的语句
    //开始事务
    $pdo->beginTransaction();
    $int_1 = $pdo->exec("update test set price=price-50 where id=1 ");
    $int_2 = $pdo->exec("update test set price=price+50 where id=2 ");
    if($int_1 == $int_2){
      $pdo->commit();
      echo "交易成功！";
    }else{
      $pdo->rollBack();
      echo "交易失败！";
    }
    $pdo->exec("update test set price=price+1000 where id=1 ");
  }catch(PDOException $e){
    //$e->getMessage()需要输出
    echo "错误".$e->getMessage();
    $pdo->rollBack();
  }




B    类 PDOStatement
a   php的预处理语句，原理：将SQL语句发送至服务器编译后，等待数据和执行命令，得到数据和执行命令后，才执行；
优势：效率比exec()和query()高，即使执行一条语句；安全性好，可以防止黑客SQL语句注入；强烈建议使用；

b   PDO准备语句、执行语句 
说明：PDOStatement 类没有构造函数，需要用 类PDO的对象调用prepare()方法（当然也有其他方法，但那些方法不建议）返回数据为PDOStatement的对象；

准备和执行语句步骤（复杂版，不采用）：
    //z1  创建PDOstatement对象，将sql语句放到服务器上（数据库管理系统上），编写后等待，没有执行；
    //说明：如果sql语句中有变量，就必须把变量用?代替，这样才能防止SQL注入；
    $statement = $pdo->prepare("insert into test values (null,?,?)");
    //除了用？，还可以起自己名字来代替，如下一条语句，注意名字前面的冒号不能少；
    //$statement = $pdo->prepare("insert into test values (null,:name,:price)");
    

    //z2  绑定参数(?)，将?和一个变量联系起来，第二个参数必须是变量了，不能为具体值；bindParam()中第一个参数数字是第几个问号？对应的参数；
    $statement->bindParam(1,$name);
    $statement->bindParam(2,$price);
    //对应上面的自定义名字赋值，这里的冒号可以有可以没有；
    //$statement->bindParam('name',$name);
    //$statement->bindParam('price',$price);
    
    //z3  给相应的变量赋上值，如果还需要执行相同语句只是值不同，那么可以再赋值，再execute()执行;
    $name='haha';
    $price ='4321';
    
    //z4  执行在数据库中准备好的语句；
    //说明：执行 执行语句后数据库中编译好的代码并没有删除，如果需要再执行，就再用execute()方法；
    $statement->execute();

备注：如果SQL语句中没有变量，则直接执行 z1 和z4；如果如果需要执行同样的SQL语句，只是参数值不同，则z1和z2写一遍，z3和z4写多变，如：z1;z2;z3;z4;z3;z4;

备注2：可以用PDOStatement::debugDumpParams方法(本身就是打印)，直接打印出一条预处理语句包含的信息。
例：$statement->debugDumpParams();

准备和执行语句步骤（简化版，采用，且用自定义名的方式，不采用?）
    //z1 创建PDOStatement对象；注意：自定义名没有引号哦；
    $statement = $pdo->prepare("insert into test values (null,:name,:price)");
    //z4 赋值执行，execute()自带赋值功能，这个赋值功能不局限于insert语句，任何SQL语句中变量，都可以被赋值；
    $statement->execute(array("name"=>'ooo',"price"=>'8888'));
备注：当prepare()里的sql语句中的变量用?代替(注意：sql语句中用问号?代替变量，?前面就没有冒号了)，用execute()赋值的参数为索引数组，当然索引数组中的值按照下标顺序赋值到相应位置问号参数上，注意索引数组是跟问号位置和个数有关，与表的参数个数无关；如果自定义名，那么用execute()赋值的参数为关联数组（特别注意：赋值只是针对自定义名字参数，不是整个字段列表），如上例，且如果表单标签name值、SQL语句自定义名字 和 数据中的字段名（这个不一定一样，只要和SQL中位置对应也行，但最好一样）三者一致时，可以直接用execute($_GET)或者execute($_POST)方式将数据插入数据库（所以采用自定义名）；
特别注意：赋值的数组要和需要赋值的参数，无论是问号还是自定义名的个数要完全一样；
特别注意2：通过问号或者自定义名防止sql注入，用execute()赋值后，再输出sql语句，语句依然是问号和自定义名，而不会被赋值，但语句照样进行；

备注2：$statement = $pdo->prepare("insert into test values (null,:name,:price)");其实这种方式中(null,:name,:price),以name为例，:name只是对应表
中第二个字段值，并不一定对应表中的name字段；
即 在insert into test (id,name,price) values (null,:name,:price)中两个括号中的
对应是位置的对应，并不存在字段名的对应（当然，如果values前面有字段名情况下，这个字段顺序可以调整，后面相应的也要调整）；当 values前面省略时，那么后面无论采用 :字段名 还是 ?方式，只和values前面的字段名，是顺序对应关系，当然采用 :字段名的方式和 execute(数组)中
数组就是关联对应了，采用?方式，则是索引对应；


c 处理数据的查询结果
$statement->fetch([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0 ]]])  从结果集中获取下一行，有点相当于mysql_fetch_array() ，参数 PDO::FETCH_ASSOC 返回关联数组；PDO::FETCH_BOTH（默认）既返回关联数组又返回索引数组；PDO::FETCH_NUM返回索引数组；这些常量在PDO-预定义常量里；
例：list($id,$name,$price) = $statement->fetch(PDO::FETCH_NUM);

$statement->fetchAll([ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array() ]]] )  返回一个包含结果集中所有行的数组，该函数指针随fetch()函数影响，即前面fetch()函数取得了行，该函数将不再取；想要返回一个包含结果集中单独一列所有值的数组，需要指定 PDO::FETCH_COLUMN 。通过指定 column-index 参数获取想要的列。详情：http://php.net/manual/zh/pdostatement.fetchall.php；
例：print_r($statement->fetchAll(PDO::FETCH_ASSOC));

$statement->setFetchMode()  为后面所有语句设置默认的获取模式，但如果后面自己fetch()和fetchAll()传递了参数模式预定义常量，那么还是以自己传递的常量为准；
例：$statement->setFetchMode(PDO::FETCH_ASSOC);
更多详情：http://php.net/manual/zh/pdostatement.setfetchmode.php

d 其他部分函数
$statement->bindColumn() 安排一个特定的变量绑定到一个查询结果集中给定的列。
例： $stmt->bindColumn(1, $name);或者 $stmt->bindColumn('calories', $cals);感觉还没有list()好用；
$statement->rowCount(void)  获取查询结果的行数（对于查询不能保证所有数据都有效），如果是影响行数语句执行则获取的是影响行数，是自动判断，不用另外加属性；
$statement->columnCount(void) 返回结果集的列数
$pdo->lastinsertid(); 获取最后插入的id；

e 用PDO存取大数据对象（不建议），数据库只是存大数据（如：图片）的名称而已，通常将大数据存在文件夹下；
e.1 在数据库建立表中存储大数据的字段类型为 blob ；
e.2 将大数据存入表
  $statement = $pdo->prepare("insert into images (mimetype,data) values (?,?)");
  $statement->bindParam(1,$_FILES['pic']['type']);
  $fp = fopen($_FILES['pic']['tmp_name'],"rb");
  $statement->bindParam(2,$fp);
  $statement->execute();
e.3 将数据取出，显示
  $statement = $pdo->prepare("select mimetype,data from images where id=?");
  $statement->execute(array(1));
  list($mimetype,$data) = $statement->fetch(PDO::FETCH_NUM);
  //告诉浏览器传递过来的是什么文件；
  header("content-type:{$mimetype}");
  echo $data;
备注：不建议采用；

f 配合PDOStatement类的对象进行事务处理：其实跟前面利用exec()和query()发送语句一样，只是把这部分换成了prepare()发送语句，其余部分没变；
例：
  //开启事务
  $pdo->beginTransaction();
  //让test表中id=1的增加100；
  $statement= $pdo->prepare("update test set price=price+:pri where id=:id");
  $statement->execute(['id'=>1,'pri'=>100]);
  //获取影响行数
  $affected_row1=$statement->rowCount();
  //让test表中id=2的减100；
  $statement->execute(['id'=>2,'pri'=>-100]);
  //获取影响行数
  $affected_row2=$statement->rowCount();
  if($affected_row1==$affected_row2){
    $pdo->commit();
  }
备注：从上面可以看出sql语句中的任何为值得东西（可以不是表的字段）都可以为变量（形式为  :变量名），且能在execute()里被赋值；

g 代码规范：
g1 prepare()语句后，必须  紧跟着至少一个execute()语句（当然绑定参数除外），即使在开启事务也一样；
g2 整个发送SQL操作数据库过程中，最好使用一个PDOStatement类对象，因为数据不断这样覆盖节省资源；
g3 猜测：操作数据库结束后还是删除PDOStatement类对象和PDO对象；



C    类 PDOException    处理异常


第十六章  memcache应用（内存做缓存），端口11211；
41 
A 基本信息
memcache是一个软件（管理系统），把数据往内存中存，消耗CPU很少，用内存较多；
Apache是进程管理方式，消耗CPU，用的内存很少；

memcache作用：php第一次取数据，第一次去MySQL取数据，将SQL语句返回php，同样数据也缓存一份到memcache，在php后面再取数据时，先到memcache控制的缓存中寻找，速度更快；
使用情况：a 缓存MySQL数据；b 缓存会话信息；

B memcache的安装
a windows下安装
a.1  网上下载memcached-1.2.1-win32.zip。解压放到某个盘下面，比如在c:\memcached
a.2  在终端（cmd）下:
  D:\AppServ>memcached.exe -d install   安装
  D:\AppServ>memcached.exe -d uninstall   卸载
  D:\AppServ>memcached.exe -d start   启动
  D:\AppServ>memcached.exe -d stop    停止
  memcached.exe -h        获取所有帮助
a.3 在启动之后连接：
  D:\AppServ> telnet 127.0.0.1 11211        连接memcache端口11211
  quit          退出
备注：这个软件跟Apache和MySQL一样放在 bin 目录下；以下命令行的地址代码，是memcache.exe本身位置，如安装代码可以是：   c:\wamp\bin\memcache.exe -d install (没有符号哦)；
在  计算机-右键-管理-服务和应用程序--服务--可以查找到memcache操作启动、停止和重启；

b Linux下安装
 安装memcache源代码
http://memcached.googlecode.com/files/memcached-1.4.10.tar.gz
b.1 首先安装依赖包libevent
      yum -y install libevent *
b.2 主包已经安装，别忘记安装libevent-devel*，不然 ./configure过不去；
      tar xzf/lamp/memcached-1.4.10.tar.gz  解压memcached
      cd/lamp/memcached-1.4.10    进入memcached目录
      ./configure--prefix=/usr/local/memcache         配置
      make && make install      编译与安装
      useradd memcache      添加memcache用户；

C 连接memcache
获取本机ip命令行 ：ipconfig
a 连接端口命令行:   telnet ip(地址) 11211(端口)     例：telnet 127.0.0.1 11211
b 显示状态信息命令行：Stats    
c 退出连接命令：quit
以上 c d 两个命令是在连接后才行；
详情：http://blog.csdn.net/zzulp/article/details/7823511
显示memcache存入内存的值：http://www.ttlsa.com/memcache/memcache-list-all-keys/
简单操作：
stats items     列出所有keys
stats cachedump key 0 为0显示全部，有时好像需要分号结束；

D memcached 服务器的管理
启动memcache常用参数（猜测：好像不用启动程序就可以在cmd中设置）
-   -p<num>     设置端口号（默认不设置为：11211，服务器端口：3306）
-   -U<num>   UDP监听端口（默认：11211，0时关闭）
-   -l<ip_addr> 绑定地址（默认：所有都允许，无论内外网或者本机更换ip，有安全隐患，若设置为127.0.0.1就只能本机访问）
-   -d    独立进程运行
·  ...-d start    启动memcached服务
·  ...-d restart    重启memcached服务
·  ...-d stop|shutdown  关闭正在运行的memcached服务（|是或者的意思）
·  ...-d install    安装memcached服务
·  ...-d install    卸载memcached服务

-  -u<username>   绑定使用指定用于运行进程<username>
-  -m<num>    允许最大内存用量，单位M （默认：64MB）
-  -P<file>   将PID写入文件<file>，可以使得后边进行快速进程终止，需要与-d一起使用
-  -M     内存耗尽时返还错误，而不是删除项
-  -c     最大同时连接数，默认是1024
-  -f     块大小增涨因子，默认是1.25
-  -n       最小分配空间，key+value+flags默认是48
-  -h     显示帮助

常用组合（在Linux用的命令）
#/usr/local/memcached/bin/memcached -d -m 256 -p 11211 -u www 127.0.0.1
#/usr/local/memcached/bin/memcached -d -m 256 -p 11211 -u www -l 127.0.0.1
#/usr/local/memcached/bin/memcached -d -m 1024 -p 11211 -u root -c 1000

备注：指定端口时最好是在1024~65535

D CMD命令
a 猜测命令作用：
---     cd  (路径)      作用：进入路径文件，例：D:\>cd wamp\bin      结束千万不要有分号；
---     cd..    作用：返回上一级路径
---     cd\   作用：返回根路径（作用后，还是会显示原来所在盘，再输入目标盘就行） 
例：
D:\wamp\bin\cd\
D:\>c:
C:\>

b 例：D:\wamp\bin\netstat -a 在开始程序可以外围查看是否启动程序信息  


E Memcache 的常用命令操作
- stats   当前所有memcached 服务器运行的状态信息
- add   添加一个数据到缓存服务器（数据不存在，则添加，存在，不更改）
- set   替换一个已经存在的数据（数据不存在，则添加，存在，则修改）
- get 从缓存服务器端提取指定的数据
-delete 删除指定的单个数据
-flush_all  清除所有数据
stats cachedump 

add和set的语法格式：<命令><键><标记><有效期><数据长度>   
get和delect的语法格式：<命令><键>
备注：
<键> -key ，是发送过来指令的key的内容
<标记>-flags，是调用set指令保存数据的时候的flags标记，随便写1就行；
有效期：数据在服务器上的有效期，如果是0，则数据永远有效，单位是秒
数据长度，block data块数据的长度，一般在这个长度后下一行跟着block data 数据内容，设置的长度，就必须输入相应长度的数据，多一个或者少一个都不行；
数据发送完成后，显示：
STORED 数据保存成功
NOT-STORED 数据保存失败，是因为服务器端这个key已经存在；
例：
add one 1 0 5
aaaaa               //这一行才是输入的值
STORED    //输入成功
更多的查看：F\来吧\php\memcache\memcache的常用命令操作；

42 PHP中memcache功能扩展模块的安装（跟安装软件不同哦）
a  把php_memcache.dll（一定要看系统是32位还是64位的哦） 放到wamp\bin\php\php5.4.16\ext 目录下；
b 修改php.ini（配置文件），在配置文件里搜索dll，找到extension=php_memcache.dll 代码的地方
c 把 extension=php_memcache.dll 写入配置文件，记着没有前面的分号，才能使用哦！

额外知识：phpinfo()返回并直接输出关于服务器所搭建的php信息；

43 操作memcache
//创建memcache对象
$mem = new Memcache;

//连接memcache服务器
$mem ->connect("localhost",11211); //第一个参数为ip，ip也要用引号抱起来；最好用addServer()代替；

//操作(可以添加入任何类型数据)，MEMCACHE_COMPRESSED作用是在数据过大时自动进行压缩；
//并且不用设置长度，如果有效期大于30天，则需要现在时间戳+需要保存时间；总结：如果永久保存时间设置为0，否则就用time()+保存时间秒数    统一设置，如下例@，这样可以和setcookie统一记忆；
$mem->add("one","this is a memcache test!",MEMCACHE_COMPRESSED,0);
$mem->set("two","this is a memcache demo!",MEMCACHE_COMPRESSED,time()+3600);@
var_dump($mem->get("one"));   //也可以返回数组；
$mem->delete("one",10)    //十秒内被删除
$mem->flush();      //删除全部

//关闭连接（如果持久连接，就不用关闭）
$mem ->close();

重点：
$mem->addServer(ip,11211);   //添加向连接池中添加一个memcache服务器（前面的connect()函数也可以直接用addServer()代替），利用其它服务器内存，添加完成后，存储数据和提取数据和原来一样，memcache自己会通过哈希算法分配（当然也可以设置权重）存储；注意利用了addServer()函数后，默认是持久化连接（需要改变，查看参考手册），不能用close()关闭；

memcache 服务器的安全防护
? 1. 内网访问
– memcached -d -m 1024 -u root –l 192.168.0.10 –p 11211 –c 1024 start
? 2. 设置防火墙
– iptables –F
– iptables –P INPUT DROP
– iptables –A INPUT –p tcp –s 192.168.0.10 –-dport 11211 –j ACCEPT
– iptables –A INPUT –p udp –s 192.168.0.10 –-dport 11211 –j ACCEPT
备注：把上面的ip换成自己的就行，？问题是ip不是唯一个啊；
看完MySQL，再看一次16.1.8；




第十七章    http协议和web本质
44 http协议：超文本传输协议，浏览器和服务器之间“沟通”的一种规范；在得到资源（即页面）后，连接立即中断；即是无状态的，无法判断是从哪个网页到这个网页的，每次进入新的网页或者刷新网页都是新的请求，http协议并不会跟踪用户；

A 请求：
a 请求行，是以什么方式请求get或者post；
b 请求的头信息，如：客户端用什么浏览器，浏览器版本，cookie等等；
具体：
– Accept:浏览器可接受的MIME类型
– Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集
– Accept-Encoding:浏览器能够进行解码的数据编码方式，比如gzip
– Accept-Language:浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 可以在浏览器中进行设置。
– Host:初始URL中的主机和端口
– Referer:包含一个URL，用户从该URL代表的页面出发访问当前请求的页面
– Content-tType:内容类型
– If-Modified-Since: Wed, 02 Feb 2011 12:04:56 GMT利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件。
– User-Agent:浏览器类型.
– Content-Length:表示请求消息正文的长度
– Connection:表示是否需要持久连接。如果服务器看到这里的值为
“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接
– Cookie:这是最重要的请求头信息之一
– Date：Date: Mon, 22 Aug 2013 01:55:39 GMT请求时间GMT

c 请求的内容，如请求方式get的话，就是地址栏？后面信息，如果请求方式post的话，就是表单信息；
备注：<img />标签也是一个请求，css文件，js文件也是；


B 响应：
a 响应行
100～199 表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程
200～299 表示成功接收请求并已完成整个处理过程
300～399 为完成请求，客户需进一步细化请求。例如，请求的资源已经移动一个新地址
400～499 客户端的请求有错误
500～599 服务器端出现错误
具体:
• 200(正常)
– 表示一切正常，返回的是正常请求结果
• 302/307(临时重定向)
– 指出被请求的文档已被临时移动到别处，此文档的新的URL在Location响应头中给出。
• 304(未修改)
– 表示客户机缓存的版本是最新的，客户机可以继续使用它，无需到服务器请求。
• 404(找不到)
– 服务器上不存在客户机所请求的资源。
• 500(服务器内部错误)
– 服务器端的程序发生错误

b 响应头，如 header("content-type:text/html;charset=utf-8")和cookie等; 头之前不能有任何输出；
具体：
– Location: http://www.brophp.com/index.php指示新的资源的位置
– Server:apache 指示服务器的类型
– Content-Encoding: gzip服务器发送的数据采用的编码类型
– Content-Length: 80 告诉浏览器正文的长度
– Content-Language: zh-cn服务发送的文本的语言
– Content-Type: text/html; charset=utf-8服务器发送的内容的MIME类型
– Last-Modified: Tue, 11 Jul 2013 18:23:51 GMT文件的最后修改时间
– Refresh: 1;url=http://www.brophp.com指示客户端刷新频率。单位是秒
– Content-Disposition: attachment; filename=aaa.zip指示客户端下载文件
– Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie
– Expires: -1
– Cache-Control: no-cache (1.1)
– Pragma: no-cache (1.0)
– Connection: close/Keep-Alive
– Date: Tue, 11 Jul 2000 18:23:51 GMT

c 响应内容

额外知识：httpwatch软件可以查看这些信息，这个在IE中可以看，在火狐中可以用httpFox插件（火狐浏览器-组件中），使用 查看-HttpFox；


45 会话控制：允许服务器跟踪同一个客户端做出的连续请求； 
会话控制用到两个技术：
a Cookie技术：将用户的信息状态，存放在客户端的计算机中；
说明：是服务器给客户端
会话原理：服务器在响应头信息中将cookie信息发送给客户端，跳转页面时，客户端又将cookie信息放在请求头信息中发送给服务器，服务器就知道用户信息了；
b Session技术：将用户的信息状态，存放在服务器中；


额外知识：变量分为四种级别、
    范围      级别    说明
a 当前页面变量    page  只能在声明处以后使用，页面完成后就释放；
b 两个页面间传递的变量  get 利用url来传递
c 会话级别      session   同一个用户在同一个网站，共享自己的变量；
d 全局      global  写到数据库或者文件中的，任何人都可以访问；

A cookie使用
a setcookie()设置cookie，
bool setcookie ( string name [, string value [, int expire [, string path [, string domain [, bool secure]]]]] )
说明：
参数1：name  Cookie 的名字，猜测：像是全局数组$_COOKIE的下标，使用 $_COOKIE['cookiename'] 调用名为 cookiename 的 cookie。
    注意：name本身是字符串（有引号包裹），但是如果数组下$_COOKIE的二维数组，则[]括号中就不要有引号了，如果有引号还要去转义；
    如：setcookie("lydia[hehe]",$hehe,time()+86400); 引用时要有引号哦，如：echo $_COOKIE['lydia']['hehe']."<br/>";
    如果想二维数组是索引下标，不能让[]空着，不然会覆盖，必须全部写出，如setcookie("lydia[0]",$hehe,time()+86400);setcookie("lydia[1]",$hehe,time     ()+86400);
参数2：value   Cookie 的值。此值保存在客户端，不要用来保存敏感数据。假定 name 是 'cookiename'，可以通过 $_COOKIE['cookiename'] 取得其值。
参数3：expire  time()+60*60*24*30 将设定 cookie 30 天后失效。如果未设定，cookie 将会在会话结束后（一般是浏览器关闭）失效(那好像天猫采用不设定)。
参数4：path  如果该参数设为 '/' 的话，cookie 就在整个 domain 内有效，如果设为 '/foo/'，cookie 就只在 domain 下的 /foo/ 目录及其子目录内有效，例如         /foo/bar/。默认值为设定 cookie 的当前目录。作用：浏览器访问这个设定目录下的网页，这些网页都能共享到这个cookie；
参数5：domain
参数6：secure
更多详情：http://www.cnblogs.com/aleaf/archive/2009/06/07/1498038.html
备注：删除也是setcookie()这个函数，只要设置时间是以前或者现在的时间戳（最好第二个参数为空字符串），那么变量就过期了，就会自动删除，但要一个个的删除，包含数组也要一个一个的下标删除；
例：setcookie("lydia[name]","",time());

额外知识：
a 转义具体用法：哪里的位置改用引号的就用，然后判断在外面引号会不会被被里面的相同的引号影响，如果影响，则里面引号需要就转义（其实引号范围可以扩大到符号）


B session使用
a  原理：相对比cookie，session将用户信息存在服务器上，在用户请求时，发送session_id（字符串） 给用户，这个信息可以存放在cookie中，也可以直接存在地址栏中，将session_id发送给用户同时，在服务器建立一个名为session_id文件保存用户信息，用户请求其他页面时，这个session_id文件中的信息就是共享的；

b  session_start(void) 功能：
b.1 开启会话session（cookie机制没有这步），只要想使用$_SESSION数组，就必须有这步;
b.2 向客户端发送一个session_id保存在cookie中，还在服务器中创建一个与客户端同名的session文件（文本），且调度php的机制使用session；
b.3 判断客户端是否有了sessionid，变量名为PHPSESSID，就会直接使用session id 开启会话，也不再在服务器端创建新文件了，直接找到同名的session id的session文件；
b.4 客户端有sessionid，而服务器端通过自动垃圾回收机制删除了对应文件，session_start(void)函数会建一个与客户端sessionid同名的session文件；
b.5 更新服务器端session_id文件，即使没有值更改，也会更改最近操作时间，这对于垃圾自动回收机制中判断过期是有效的；
b.6 有自动能调用session_set_save_handler("open","close","read","write","destroy","gc");中open(),close(),write(),read(),destroy(),gc()的功能，还有给他们传递session id和session内容的功能，记住是自动调用；
备注：这个函数前面不能有任何输出，因为它也走头信息；总结起来该函数就要开启会话，然后建立客户端$_COOKIE中session_id，和服务器端对应的session文件；

c $_SESSION 这个全局数据跟其他数组的使用是一样的（而cookie则需要专门的setcookie()函数），我们给这个全局数组赋值什么，它还会将这个值保存到session_id的文件中
 （真实的大项目应该要把文件内容加密），但是条件是使用前必须用session_start() 开启会话；

d 删除数组$_SESSION
unset($_SESSION['键名'])，可以删除内存中由Session数组保存的变量；
$_SESSION=array()，清除所有变量；
备注：切记不能用unset($_SESSION);这样会把全局数据也删掉的；

e bool session_destroy(void); 作用：删除服务器端保留的session信息文件；

f 如果session基于cookie，就还要删除客户端保留的cookie文件；如：setcookie(session_name(),"",time()-3600);
备注：session_name() 输出session id对应的在全局数组$_COOKIE中的键名；

备注：即用session机制，要删除三个东西，一，清空全局数组，二，删除session_id在cookie数组中的键和值（这个采用不设置cookie()第三个参数，即关闭浏览器就删除来实现），三，删除session_id文件；
例：
  //z.1 开启session
  session_start();
  //操作$_SESSION数组
  $_SESSION['name'] = "neo";
  //清空数组
  $_SESSION = array();
  //判断是否基于cookie，如果是，则删除$_COOKIE中的session_id的键和值；
  if(isset($_COOKIE[session_name()])){
    //特别注意一定要加第四个参数'/'，因为session_start();操作时默认加了'/'；
    setcookie(session_name(),"",time()-3600,'/');
  }
  //z.5 删除session_id文件
  session_destroy();

g Session配置选项
– session.auto_start = 0 ; 在请求启动时初始化session
– session.cache_expire = 180 ; 设置缓存中的会话文档在 n 分钟后过时
– session.cookie_lifetime = 0 ; 设置按秒记的cookie的保存时间，SessionID在客户端Cookie储存的时间，相当于设置Session的过期时间，为0时表示直到浏览器被重启
– session.auto_start=1，这样就无需每次使用session之前都要调用session_start()。但启用该选项也有一些限制，如果确实启用了 session.auto_start，则不能将对象放入会话   中，因为类定义必须在启动会话之前加载以在会话中重建对象。
– session.cookie_path = / ; cookie的有效路径
– session.cookie_domain = ; cookie的有效域
– session.name = PHPSESSID； 用在cookie里的session的名字
– session.save_handler = files ; 用于保存/取回数据的控制方式
– session.save_path = /tmp ; 在 save_handler 设为文件时传给控制器的参数， 这是数据文件将保存的路径.
– session.use_cookies = 1 ; 是否使用cookies

h 其他部分session函数
session_id()  返回session_id的值，而session_name()则返回$_COOKIE的键，则$_COOKIE[session_name()]=session_id();
session_set_save_handler()

i Session自动垃圾回收机制
说明：垃圾session文件要被删除具备条件：
a 该session_id文件得过期，即离该用户上次执行session_start()（即上次请求页面）的时间超过了php配置文件中session.gc_maxlifetime规定的时间；
b 有其他用户执行session_start()，并且触发了 gc_probability/gc_divisor 这个概率，启动了垃圾回收机制；
备注：在php配置文件中
session.gc_maxlifetime 设置session过期时间，默认为1440秒（24分钟）、
session.gc_probability   设置概率分子（默认1）
session.gc_divisor      设置概率分母（建议1000~5000）
session.cookie_lifetime = 0   默认为0代表关闭浏览器时删除相应的$_COOKIE对应session_id和值，如果没有关闭浏览器，但启动了垃圾回收机制删除了相应在服务器端的session_id文件，如果再次刷新，服务器端又会将浏览器发送给他的cookie对应session_id建立一个同名的session_id文件；


j 基于URL传递session id，作用：在用户禁用cookie时，通过地址栏来传递session id;
j.1 在windows在最简单方法（在windows下采用）
<?php
  //判断SID传递的值是否为空
  $sid = !empty($_GET[session_name()]) ? $_GET[session_name()] ： '';
  //如果$sid有值，则说明用户禁用了cookie，得采用url传递
  if($sid !=''){
    //这个函数本来没有参数，如果有参数，作用是告诉session_start()可以用这个传进来的参数作为session_id用；
    session_id($sid);
  }
  session_start();
      ...
?>
  //SID 这个预定义常量本身作用就有判断用户是否禁用cookie，如果禁用，则SID值为 session_name().'='.session_id() ，如果没有禁用，则SID为空；
  <a href="one.php?<?php echo SID;?>">one</a><br/>
  <a href="two.php?<?php echo SID;?>">two</a><br/>

备注:以上代码缺点：每个链接都必须加<?php echo SID;?>，工程量大；
备注：设置php.ini中session.cookie_httponly = 1 作用：设置PHPSESSID的httpony属性

j.2 在Linux 下
在使用Linux系统做服务器时， 在编辑PHP时， 如果使用了—enable-trans-sid配置选项， 和运行时选项session.use_trans_sid都被激活， 在客户端禁用cookie时， 相对的url将被自动修改为包含sessionid, 如果没有配置， 或使用windows系统作为服务器时， 可以使用常量SID.
• 建议使用Linux并配置好，因为这样可以不必在每个链接中加入SID；


k session文件的存储位置
k.1 存储在服务器内存中，速度快，只要内存够用，这种方式极佳；
k.2 存储在数据库中，速度较好；
k.3 存储在默认临时文件夹下，无需另外操作，但速度慢；
备注：前两种适合大项目，第三种适合小项目；


46 session的储存方式：files（默认）   user     memcache   
备注：上面三个值为php配置文件session.save_handler属性的选项；
A   user存储方式步骤：（下面代码不建议采用，而是采用封装好的类）
//z.1 更改php配置文件中 session.save_handler = user  
ini_set('session.save_handler','user'); 
//z.2 注册过程，让php自己处理session时，找到这个函数的几个周期来完成
session_set_save_handler("open","close","read","write","destroy","gc");

//创建自定义保存session文件（这里举例为hehe），设置路径$path；
$path = "d:/wamp/hehe/";

//z.3 声明各个session阶段处理函数
//开启时，session_start(),猜测：下面$name等变量应该是session_set_save_handler()给的
function open($path,$name){
  return true;
}
//关闭
function close(){
  return true;
}
//读取 默认传递session id；读取如：echo $_SESSION['username']，
function read($sid) {
  global $path;
  $filename = $path."mz_".$sid;
  return @file_get_contents($filename);
}
//写入 $_SESSION['username'] = 'meizi';默认传递session id;$data是$_SESSION数组转化为某种字符串格式，以存在文件中（类似于json数据格式）；
//特别注意：这儿很怪，如果过程化写程序，对象$pdo如果在函数write(){}外声明，通过global $pdo;是不能引进函数内使用的，只有在这个地方不行，如果在类中，$pdo为属性，当然可以直接用，在其他地方也是可以通过global来引进对象的；
function write($sid, $data) {
  global $path; //纯变量，不是对象，也可以被引用
  $filename = $path."mz_".$sid;
  return file_put_contents($filename, $data); //如果没有$filename对应的文件，file_put_contents会自动建立；
}
//销毁 session_destroy()，默认传递session id;
function destroy($sid) {
  global $path;
  $filename = $path."/mz_".$sid;
  return @unlink($filename);
}
//回收垃圾，默认传递session生命期；
function gc($maxlifetime) {
  global $path;
  foreach(glob($path."mz_*") as $file) {
    //只删除过期的
    if(filemtime($file)+$maxlifetime < time()) {
      unlink($file);
    }
  }
}
//必须在session_start()之前
session_start();

备注：注意最后一步session_start();前的代码作为文件引用也行，但是一定要在session_start()的前面，并且每次执行session_start()前四步是一定会执行，顺序是开启、读取、写入、关闭；有把上面代码归为类的文件；
额外知识：@作用：阻止警告输出；
glob()— 寻找与模式匹配的文件路径
在类中回执函数时本类的方法，要通过数组来引用，例：
session_set_save_handler(
  array(__CLASS__, "open"), 
  array(__CLASS__,"close"),
  array(__CLASS__, "read"), 
  array(__CLASS__, "write"),
  array(__CLASS__, "destroy"), 
  array(__CLASS__,"gc"));

备注：类似于call_user_func_array();操作；
B 利用user方式使用数据库存储session
a 原理：利用PDO对象，操作数据库，存储session；
session_set_save_handler()函数功能设置了回执函数（这个函数没有函数体），但是调用session函数时，还是用原来函数名，如：销毁session文件代码，session_destroy();
数据库表(session)字段(前三个为必选)：
内容    字段
记录session id  sid
修改时间    utime
session数据 sdata
ip     用户ip uip
user_agent浏览器 uagent


额外知识：获取用户ip
判断ip是否合法:filter_var($ip,FILTER_VALIDATE_IP);
备注：这个函数还可以判断email、URL等等；详情：http://www.poluoluo.com/jzxy/201207/170024.html
获取浏览器信息：$_SERVER['HTTP_USER_AGENT']，或者采用get_browser();



C  memcache存储方式原理：利用memcache能向内存中存储key和value，并且有规定过期时间这些特性，向内存存储session信息；如果服务器内存够用，这种方式极佳，有专门的类（已下载）

抛开Cookie使用Session，即假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：

       1. 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。
       2. 手动通过URL传值、隐藏表单传递Session ID。
       3. 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。





第十八章    模板引擎

47 自定义模板引擎步骤（主要应用了字符串的替换）
a 在模板（hmtl代码）中插入需要的变量名；例：<title>{$title}</title>
备注：变量外的符号可以改变；
b.1  在php代码中，向模板分配变量（利用类的方法），存在类的属性数组中，下标为模板中的变量名；
注意：分配变量时，函数形参传递的是变量对应的字符串，如例的话:$smarty("title",$tit);
b.2  在php代码中，用正则找到模板中的变量，替换成php内嵌html形式，保存文件，再include包含此文件（就执行了）；

48 Smarty使用
A Smarty类的部分方法
$smarty->setTemplateDir(路径);  设置引用模板路径
$smarty->setCompileDir(路径);   设置保存编译目录（新文件保存）
$smarty->addTemplateDir(路径);  添加引用模板路径
$smarty->setConfigDir(路径)   设置配置文件目录
$smarty->setPluginsDir(路径)    设置插件目录(注意是plugins有s)
$smarty->addPluginsDir(路径)    添加插件目录(注意是plugins有s)
A 使用步骤
//z.1 包含smarty类
include "./libs/Smarty.class.php";  //注意Smarty首字母大写
//z.2 创建对象
$smarty = new Smarty;
//z.3 设置允许自定义定界符中使用空格
$smarty->auto_literal=false;
// 更改引用模板和编译文件的目录（可选）
$smarty->setTemplateDir('./hehe');  //默认是 './template'  和当前文件夹，在这两个位置寻找模板文件；
$smarty->setCompileDir('./haha'); //默认是 './templates_c'，没有这个文件夹会自动创建  
//z.4 设置定界符号
$smarty->left_delimiter = '<{';
$smarty->right_delimiter = '}>';
//z.5 分配变量，记着传入的是变量名的字符串  
$smarty->assign('title',"this is a demo");
//z.6 显示页面，传入参数为模板文件（当然可以tpl也可以html）
$smarty->display('test.tpl');
特别注意：模板中的相对路径（如图片地址等）是相对于访问的PHP文件，不是模板文件；而引用模板的路径时相对于前面$smarty->setTemplateDir()的路径或者默认template的文件夹；
网页文件布局说明：
a.1 前台页面写在www文件夹下；
a.2 后台页面写在www/admin/下
a.3 smarty初始化页面写在当前页面，并且里面所有的包含文件路劲，采用绝对路径，这里采用define ('ROOT',str_replace("\\","/",dirname(__FILE__))."/") ，__FILE__显示所在文件的路径+文件名+后缀，而且被其他网页包含，都还是显示代码中直接有__FILE__路径和文件；


49 smarty知识
A comments注释：采用定界符里两个**，采用设置的定界符为例： <{*这里写注释信息*}>

B 变量
a 从php分配的变量：从数据库中找到数据给前台；
assign()的多种用法
//z.1 给模板中变量<{$var}>
$smarty -> assign("var", "!!!!!!!!!!!!!!!!!1");
//z.2 同时给模板中<{$title}>、<{$author}>和<{$content}>
$smarty -> assign(array("title"=>"111111", "author"=>"222222", "content"=>"this is a demo!"));
//z.3 给模板中<{$mz}>赋值一个对象，并且在模板中可以直接调用属性和方法；
$smarty -> assign("mz", new Person());
模板中···
<{$mz->name}><br>
<{$mz->say()->eat()}> <br>
//z.4 给模板中的变量<{$arr1}>赋值数组；
$smarty -> assign("arr1", array("hello"=>array("one", "two", "three")));
模板中调用数组方法
<{$arr1['hello'][0]}> <br>  //smarty 3支持
<{$arr1.hello[0]}> <br> //smarty 2和3 都支持；
备注：无论赋值什么，被赋值变量在assign()中都以字符串形式出现；


b 从配置文件中读取变量，适用情况：用户改变配置文件，就改变页面外观时使用；
设置步骤：
// z.1  设置配置文件目录（这行代码是跟$smarty->setTemplateDir('./hehe');在一个文件中）
$smarty->setConfigDir(ROOT.'configs/');
// z.2  在设置的配置文件目录下建立相应的配置文件 sns.conf;
// z.3  在模板中包含z.2建立的配置文件，且该文件下全部是键值对；
<{config_load file="sns.conf"}>
<{config_load file="sns.conf" section="index"}>   //引用局部（引用局部时，全局变量在该模板中也能用）
//配置文件内容
border=10
bgcolor=yellow    //这是全局变量，注意没有任何语句结束符哦；
[index]     //这下面是针对index板块的局部变量
height=50     
// z.4  在模板中引用配置文件变量，通过<{ #变量# }>来引用
<table border="<{#border#}>" >
或者<table border="<{$smarty.config.border}>" >


c 保留变量，存在于变量smarty中的变量，不用再通过assign()分配；
例：
<{$smarty.get}>       //表示$_GET数组
<{$smarty.cookies}>    //表示$_COOKIE数组；注意前面的cookies有s哦；
<{$smarty.now}>   //表示当前时间戳
<{$smarty.template}>  //返回经过处理的当前模板名（不包括目录）。
<{$smarty.current_dir}> //返回经过处理的当前模板目录名。
<{$smarty.const.ROOT}>  //直接访问php常量
等等···

C 变量修改器：在模板中处理变量；
a 语法：<{$var | 函数名:参数2:参数3:参数4 | 函数名2}>
例：<{$var | upper }>
<{$var|default:"默认值"}>  //没有变量$var时的默认值
<{$var|truncate:30:"@@@"}>  //截取，第二个参数是字符数，默认截取后面3位用...代替，可以设置，并且默认是按整个单词截取；除非第四个参数为true，就是按字母截取
<{$var|truncate:10}>    //截取中文，第二个参数是字符数，例子中只截取7个汉字，后面三个用...补充；
备注：直接在模板中使用php函数也可以达到变量修改器效果；

b 自定义变量修改器：利用$smarty->registerPlugin("modifier","修改器名","函数名");
例：
function fontstyle($str,$fontsize="3",$color="black"){
  return "<font size={$fontsize} color='{$color}'>{$str}</font>";
}
$smarty->registerPlugin("modifier","mystyle","fontstyle");
模板中用法：
<p  ><{$content|mystyle}></p>
备注：函数的第一个参数必须是变量修改器 | 前面的变量，如果不是可以通过声明另一个函数，来改变一下参数位置；

c 真实项目中，这个变量修改器只是美工用，所以最好不要写在php代码中，那么实际自定义变量修改器步骤
//z.1 设置引用插件目录
$smarty->addPluginsDir(ROOT."plugins/");
//z.2 在设置的目录内，文件的命名必须遵循的规则，modifier.自定义变量修改器函数名.php
//z.3 在php文件内的函数名必须遵循的规则，function smarty_modifier_函数名(){} 每个具体引用时，还是只写函数名；
//z.4 函数的参数第一个必须是要处理的变量；
备注：这种方式就不用再用$smarty->registerPlugin()方法；模板中<{$str|myfunc}>这个部分最终结果就是函数返回值；


D 函数
a 内置函数
了解内容：
a.1 变量的声明
<{assign var="变量名" value="变量值"}>    //这句只是声明变量，并不输出
<{$变量名}>        //这句才有输出功能；
简写：
<{assing "two" "this is  a demo!"}> //声明变量two，但不输出；
最简写：
<{$three="this is a demo"}>     //声明变量three，跟php一样了，但不输出（采用）
<{$neo['one']="this is one"}>   //声明数组（采用）
<{$neo['one']}>     //显示数组
备注：添加数组元素也可以通过append（不建议）；
例：
<{append var="数组名" value="数组元素值" index="下标"}>

a.2 if语句（重点）
语法：
<{if}>
...
<{elseif}>
...
<{else}>
...
<{/if}>
备注：标签<{if }>中()只是用来改变优先级的，当然标签内还可以使用php函数；在整个分支结构里还可以嵌套；
注意：标签中的比较运算符最好用备用词，如：== eq 、!=  neq 、> gt 、 < lt 、 >= gte 、 <= lte 、！ not（非） 、% mod、=== ===；

a.3 循环（不常用）
a.3.1 for循环
语法：
<{for $var=$start to $end step 3 max=3}>
...
<{forelse}>
...
<{/for}>
备注：step 和max(设置最多循环次数)是可选择的，但$start必须小于$end ，<{forelse}>也是可选择的，并且条件不成立时执行；

a.3.2 while循环
<{while $var lt 100}>
...
<{$var++}>
<{/while}>


a.4 foreach (smarty2和smarty3完全不同，我这儿直接忽略了smarty2的用法)
语法：
<{foreach $arr as $key=>$value}>
  
<{foreachelse}>
  数组不存在或者数组为空时执行代码
<{/foreach}>

备注：
z.1 遍历中的键值$key可以像php代码一样省略；
z.2 这种遍历方式，已经将数组信息保存到$value(这个可以随意命名)，
<{$value@index}>    包含当前数组（与$value对应数组）的下标，开始时为0。
<{$value@iteration}>  包含当前循环的迭代，总是以1开始，这点与index不同。每迭代一次值自动加1。
<{$value@first}>    当{foreach}循环第一个时first为真
<{$value@last}>   当{foreach}迭代到最后时last为真。
<{$value@show}>   show属性用在检测{foreach}循环是否无数据显示，show是个布尔值（true or false）。
<{$value@total}>    total包含{foreach}循环的总数（整数），可以用在{forach}里面或后面。
例：
<{foreach $myNames as $name}>
<{if $name@iteration is div by 4}>
<b><{$name}></b>
<{/if}>
<{$name}>
<{/foreach}>

备注:还有一个section遍历索引数组（不建议）；


b 自定义函数：分为一个标签的函数和两个标签的函数（块级函数）；
b.1 自定义函数标签函数（类似于自定义变量修改器）
方式一（不建议）：在php代码中利用$smarty->registerPlugin("function","模板中函数名","php代码函数名");
方式二（采用）：
//z.1 设置引用插件目录
$smarty->addPluginsDir(ROOT."plugins/");
//z.2 在设置的目录内，文件的命名必须遵循的规则，function.自定义函数名.php
//z.3 在php文件内的函数名必须遵循的规则，function smarty_function_函数名(){}  具体引用时，还是只写函数名；
//z.4 函数的参数，第一个参数自动被赋值为模板中该函数标签的属性构成的索引数组，第二个参数自动被赋值为smaty对象；
备注：这种方式就不用再用$smarty->registerPlugin()方法；
例：
在插件function.hello.php代码：
<?php
  function smarty_function_hello($args,$smarty){
    //内容在属性中；
    return "<font size={$args['size']} color={$args['color']}>{$args['content']}</font>";
  }
在模板文件中的代码
...
<p><{hello size=20 color='red' content='这就是内容！'}></p>
备注：注意函数在模板中语法；

b.2 自定义块级函数（类似于自定义变量修改器）
方式一（不建议）：在php代码中利用$smarty->registerPlugin("block","模板中函数名","php代码函数名");
方式二（采用）：
//z.1 添加引用插件目录
$smarty->addPluginsDir(ROOT."plugins/");
//z.2 在设置的目录内，文件的命名必须遵循的规则，block.自定义函数名.php
//z.3 在php文件内的函数名必须遵循的规则，function smarty_block_函数名(){}   具体引用时，还是只写函数名；
//z.4 函数的参数，第一个参数自动被赋值为模板中该函数标签的属性构成的索引数组，第二个参数自动被赋值块级标签中内容，第三个参数自动被赋值为对象smarty，第四个参数为引用参数，开始为true，结束为false；
例：function smarty_block_hello($args,$content,$smarty,&$repeat){}
备注：自定义函数标签或者块级标签，取决于操作内容是放在一个标签内，还是两个标签中间；
例：
在插件block.myfunc.php中代码：
<?php
  function smarty_block_myfunc($args,$value,$smarty,&$repeat){
    return "<font size={$args['size']} color={$args['color']}><b>{$value}</b></font>";
  }
在模板文件中的代码
...
<p><{myfunc size=4 color=blue }>见证奇迹...<{/myfunc}></p>
备注：这儿的size最大好像是7，超过也按7算；



E 模板继承 ：继承父模板中子模板能用到部分，通过块级标签可以更改；
a 继承方式
方式一：子模板中什么都不写，只需要在子模板对应的php文件中$smarty->display("extends:parents.tpl | child.tpl");（不建议）
方式二：在子模板中编写 <{extends "parent.tpl"}>    //这样就可以继承父模板中的代码；

b 更改继承来的代码
前提：在父模板中把可能会被更改的代码用块标签<{block name="name_1"}> 可能会被更改的代码块 <{/block}>
说明：子模板标签<{block name="name_1" 关键字}>子模板内容<{/block}>中可以具有关键字，父模板中没有（除非父模板也继承）
b.1  关键字省略，则子模板中内容完全替换父模板中<{block name="name_1" }>父模板内容2<{/block}>的父模板内容；
b.2  关键字为append ，则子模板内容插在父模板内容后面，一起显示；
b.3  关键字为prepend，则子模板内容插在父模板内容前面，一起显示；
b.4  子模板内容中，可以用<{$smarty.block.parent}>来代替父模板内容；
b.5  父模板内容中，可以用<{$smarty.block.child}>来代替子模板内容，特别注意：访问父模板对应php文件是不会显示<{$smarty.block.child}>对应的子模板内容，而原理是父模板内容中包含子模板内容，再由子模板继承下来，由子模板对应的php文件显示；
例：
parent.tpl
<html>
  <head>
    <title>这是一个测试</title>
  </head>
  <body>
    <{block name="one"}><p>更改这个</p><{/block}>
    <{block name="two"}><p>测试插入顺序</p><{/block}>
    <{block name="three"}><p>测试插入顺序</p><{/block}>
    <{block name="four"}><p>测试父子模板内容</p><br/><{/block}>
    <{block name="five"}>测试父子<{$smarty.block.child}>模板内容<{/block}>
  </body>

<html>
****************************
child.tpl
<{extends "parent.tpl"}>
<{block name="one"}>
<h1>改变</h1>
<{/block}>
<{block name="two" append}>
插在父模板内容后面
<{/block}>
<{block name="three" prepend}>
插在父模板内容前面面
<{/block}>
<{block name="four" }>
这个可以<{$smarty.block.parent}>随意<br/>
<{/block}>
<{block name="five" }>
可以随意
<{/block}>

50 页面静态化：利用缓冲将用户访问页面存起来，供其他用户访问，减轻用户直接访问，给数据库带来的压力；
A 部分函数（了解）
ob_start()  — 打开  输出控制缓冲，从这条代码开始，到ob_get_contents();函数结束的内容进入缓冲区；
ob_flush() — 冲刷出（送出）   输出缓冲区  中的内容，不会销毁  输出缓冲区
ob_get_contents() - 返回输出缓冲区的内容
ob_clean() - 清空（擦掉）输出缓冲区

ob_end_flush() - 冲刷出（送出）输出缓冲区内容并关闭缓冲，会销毁缓冲区。实验证明：执行ob_end_flush()后，执行ob_get_contents()，依然可以获取缓冲区内容。

ob_end_clean() - 清空（擦除）缓冲区并关闭输出缓冲
例：
ob_start();
...
$content = ob_get_contents();
file_put_contents("new.html",$content);
ob_flush();

B 利用smarty做缓存（重点）
步骤：
//z.1 在smarty初始化文件smarty.inc.php（自己写的）中设置缓存属性；
//设置缓存时间（秒）
$smarty->cache_lifetime = 10;
//设置缓存文件位置
$smarty->setCacheDir(ROOT."/cache/");
//开启缓存的功能，true为开启，false为关闭；
$smarty->caching = true;

//z.2 在需要缓存php文件代码中判断文件是否已经被缓存，记着更改相应模板文件；
if(!$smarty->isCached("index.tpl",$_SERVER['REQUEST_URI'])){ 

//isCached()判断如果文件已经被缓存返回真；$_SERVER['REQUEST_URI']只是文件名前缀，为区分缓存文件设计的；
  这儿放需要被缓存代码，但这儿没有display()函数哦；
}

//z.3 上面的if语句外面，放不需要缓存的代码，如需要实时更新的信息；但特别注意：不需要缓存的信息的显示，需要在模板中对应的代码由<{nocache}><{/nocache}>包裹；
//这种方式实现的原理也就是ajax，下面为实时时间例子
$smarty->assign("time",date("Y-m-d H:i:s"));

//z.4 显示页面，注意只有这儿统一用display()函数显示页面，不要在z.2 中也写display()函数，且记着更改相应模板文件；
$smarty->display("index.tpl",$_SERVER['REQUEST_URI']);  //与第二步中的判断对应，第二个参数与缓存文件名有关；

//z.5 删除静态化文件（就算时间过期，也不会自动删除），最好把分类到子目录中，这样有利于删除，怎么做呢？？？？？？？？
$smarty->clearAllCache(300); 

备注：清除缓存 
clearCache() 清除指定模板的缓存
例：clearCache("index.tpl",$_SERVER['REQUEST_URI']);  //好像删除不了，还得进一步验证；
你也可以通过cache_id删除指定缓存目录下的子目录中的缓存文件，如：
 $smarty->clearCache(null, 'admin|user|');
 表示删除$cache_dir/admin/user/目录下的所有缓存文件。

clearAllCache()清除所有缓存；        //可行；
$smarty->clearAllCache(时间秒数);   删除超过多少时间的所有静态化文件；
例：$smarty->clearAllCache(3600);         //删除离上次刷新（即更新或修改文件）超过一个小时的文件；


*****CI***********
备注：模板的js代码中，可以用<?=$var?>的变量，测试：jQuery行不行？？测试，不在模板中，而是在单独js文件中行不行？？？
答：无论是js还是jQuery在模板中都能被解析，单独文件中不行；
备注2：php类中方法名与类名相同（两个都不区分大小写），则该方法相当于构造函数，即功能与__construct()相同；


51 获取文件内容显示：
a 获取文件内容，利用 file_get_contents();
b 告诉浏览器做好接收准备，利用header();
c 输出需要显示内容；
例：
$str = file_get_contents('./uploads/hh.jpg');
header('content-type:image/jpeg');
echo $str;

52 页面跳转方式
a html标签方式：
<meta http-equiv="Refresh" content ="多少秒后跳转;url=跳转地址"/>
例：
<html>
  <head>
    <meta http-equiv="Refresh" content ="3;url=http://www.youku.com"/>
  </head>
  <body>
    <p>页面跳转</p>
  </body>
</html>

b js方式：
方式一：window.location.href="http://www.baidu.com";//这个在本窗口打开(window.可省略)，如：location.href="http://www.baidu.com;
方式二：  window.open("http://www.baidu.com");//在另外的窗口打开(window.可省略)；

 <script>setTimeout('location="http://www.baidu.com"',5000);</script> 备注：js做跳转，第一个参数一定要背引号包裹，页面可以显示信息，该代码是在html文件中；或者写成：<script>setTimeout(function(){location="http://www.baidu.com"},5000);</script> 
备注：exit()函数功能：执行到这个函数时，脚本结束，即后面的所有代码不会执行，但是它前面的该执行的代码会得到执行，并且如果前面有延迟函数等等也会得到执行（如前面echo输出js函数setTimeout()等）；
例：<script>window.setTimeout("window.location='<?php echo site_url('home/index')?>'",3000);</script>

c header文件头(php)方式：
header('location:http://www.youku.com');
header('location:index.php?c=admin&a=index');用于本网站跳转，可以不使用域名
header('refresh:5;url=http://www.youku.com');
这个做跳转页面，页面就不能显示任何信息；
在CI中，这样也行：
$url = site_url('goods/comment');
$url = "Refresh:5;url={$url}";
header($url);

d CI框架url（需要加载url辅助函数）
redirect()函数，原理：其实改造header()；
例：redirect('admin/main/index');
备注：用法和site_url()相似，自动补充前面的路径到controller文件夹；

c 后台无法直接跳出前台frame框架，要借助js；
例：
$url = '<script>top.location.href="'.site_url().'admin/privilege/login"</script>';
exit($url);


53 递归注意事项：
a 必须有return返回，无论是返回 NULL 还是其他数据；
b 明确要做什么，然后按递归成功思路写代码，无论真实数据递归次数多少，思路按只能成功递归一次写代码，
递归一次后数据就截止；
c 递归判断语句一定要在 引用递归代码前；
额外知识：超过二维数组，用var_dump输出到浏览器时，会省略三维；


54 /* 设置数据，保存该页面url */
$url['url'] = 'http://'.$_SERVER['SERVER_NAME'].':'.$_SERVER["SERVER_PORT"].$_SERVER["REQUEST_URI"]; //这个是提取方法（即提取页面的完整地址信息）,不采用闪出数据了；
//保存在cookie中
$this->session->set_userdata($url);


55 获取客户端和服务器端IP
/**getenv()是php原生函数
 * 获取客户端IP地址
 * @return string
 */
function get_client_ip() { 
    if(getenv('HTTP_CLIENT_IP')){ 
        $client_ip = getenv('HTTP_CLIENT_IP'); 
    } elseif(getenv('HTTP_X_FORWARDED_FOR')) { 
        $client_ip = getenv('HTTP_X_FORWARDED_FOR'); 
    } elseif(getenv('REMOTE_ADDR')) {
        $client_ip = getenv('REMOTE_ADDR'); 
    } else {
        $client_ip = $_SERVER['REMOTE_ADDR'];
    } 
    return $client_ip; 
}   
/**
* 获取服务器端IP地址
 * @return string
 */
function get_server_ip() { 
    if (isset($_SERVER)) { 
        if($_SERVER['SERVER_ADDR']) {
            $server_ip = $_SERVER['SERVER_ADDR']; 
        } else { 
            $server_ip = $_SERVER['LOCAL_ADDR']; 
        } 
    } else { 
        $server_ip = getenv('SERVER_ADDR');
    } 
    return $server_ip; 
}



57 clearstatcache()
/*php原生函数：清除一些函数缓存，这些函数主要是判断文件和文件夹信息的函数，因为这些信息一致在变化着，如果防止在脚本执行过程中，这些信息发生变化，最终取得的信息不精确；如：stat()、lstat()、file_exists()、is_writable()、is_readable()、is_executable()、is_file()、is_dir()、is_link()、filectime()、fileatime()、filemtime()、fileinode()、filegroup()、fileowner()、filesize()、filetype()、fileperms()*/

58 运算符简单记忆（从左到右，优先级升高，没写出的如：< .= 参照相应运算）：
and  =  &&  ==  +-  !  ++
备注：and代表and、or、xor逻辑运算；一个和两个等号间是&&、||逻辑运算(注意and运算符并不是&&的别名，and的优先级小于赋值运算符，赋值运算符小于&&)；一个和两个加号(减号)是非；
备注：PHP并不完全遵守优先级的定义, 这个在PHP的手册中也有说明:
Note: Although = has a lower precedence than most other operators, PHP will still allow expressions similar to the following: if (!$a = foo()), in which case the return value of foo() is put into $a.

laruence你好：
问一个php运算符优先级的问题
$t == 1 && $tt = 2
按照php运算符优先级应该是
(($t == 1) && $tt) = 2
这个顺序执行，但实际上应该是
($t == 1) && ($tt = 2)
我有些不太理解。

其实也简单, 运算符优先级是在存在二义性文法的时候的一种规约规则选择的手段, 而PHP的语法分析文件定义中, 却让等号和T_BOOLEAN_AND(&&)之前不存在了规约冲突:

expr_without_variable:
  // 有隐规则存在, 相当于T_BOOLEAN_AND成为了"一元操作符".
  |   expr T_BOOLEAN_AND  { zend_do_boolean_and_begin(&$1, &$2 TSRMLS_CC); } expr
  

58 函数引用：利用& 实现，让函数返回的变量与接收函数返回的变量建立引用关系；
猜测：函数的引用最终也是变量的引用(将指向同一个内存地址)；
如：$result = &$res;
例：
function &foo()
{
    static $var = 0;
    return ++ $var;
}    

$result1 = foo();
$result2 = & foo();
foo();

echo $result1;//output is 1
echo $result2;//output is 3
此时result2是对函数内var变量的引用，所以foo执行三次后,var值为3，result2也为3，但是result1只是获得函数执行第一次的返回值，所以为1。
如果你使用了&符号，但是在使用时不加&，这个函数的效果就跟未使用该符号是一样的。

function foo1()
{
    static $var = 0;
    return ++ $var;
}    

$result1 = foo1();

foo1(); 

echo $result1;//output is 1
此时foo1()和foo()在达到的效果上是没有区别的，但是如果你未加&符号，又想使用引用返回，那么就会报错。

function foo2()
{
    static $var = 0;
    return ++ $var;
}    

$result2 = & foo2();//error here

foo2(); 

echo $result2; 


59 获取XML数据
说明：获取XML有很多种方法，详情：http://www.imop.us/welcome/categoryview/MTgwNA==
现在采用一种简单的simpleXML(原生php，不用再安装什么)
第一步：实例化XML对象
simplexml_import_dom()  从 DOM 节点获取 SimpleXMLElement 对象。 
simplexml_load_file() 从 XML 文档获取 SimpleXMLElement 对象。 
simplexml_load_string() 从 XML 字符串获取 SimpleXMLElement 对象。
第二步：获取数据
var_dump($xml);
备注：还有其他操作，详情可以参考手册或者：http://www.w3school.com.cn/php/php_ref_simplexml.asp
例1：
<?php
  $xmlstring = <<<XML
  <?xml version="1.0" encoding="ISO-8859-1"?>
  <note>
  <to>George</to>
  <from>John</from>
  <heading>Reminder</heading>
  <body>Don't forget the meeting!</body>
  </note>
XML;

  $xml = simplexml_load_string($xmlstring);

  var_dump($xml->to);
?>
例2：
<?php
  
  $str = "<?xml version='1.0' encoding='UTF-8' ?>
      <Message>
        <Body>
            <Mft>
              <Ceshi>1</Ceshi>
            </Mft>
            <Mft>
              <Ceshi>2</Ceshi>
            </Mft>
            <Mft>
              <Ceshi>3</Ceshi>
            </Mft>
            <data>
              <Ceshi>4</Ceshi>
            </data>
        </Body>
      </Message>";

  $xml = simplexml_load_string($str);
  /*children()方法返回的是直接子标签数组，$child就直接代表Mft和data标签*/
  foreach ($xml->Body->children() as $key=> $child)
  {
    echo $key.' => '. $child->Ceshi.'<br/>';
  }


60 递归：分层看，以变量储存函数返回值,再展开递归函数分析的方式来看递归；
例：
function addslashes_deep($value)
{
    if (empty($value))
    {
        return $value;
    }
    else
    {
        return is_array($value) ? array_map('addslashes_deep', $value) : addslashes($value);
    }
}
分析：
用$arr = array_map('addslashes_deep', $value);
再展开：
$map[0] = addslashes_deep($value[0]);
    $array = array_map('addslashes_deep', $value);
    ...
$map[1] = addslashes_deep($value[1]);
$map[2] = addslashes_deep($value[2]);
...


61 设置完整WEB_ROOT代表域名+项目目录
define('WEB_ROOT','http://'.$_SERVER['HTTP_HOST'].strstr($_SERVER['REQUEST_URI'],'/index.php',TRUE)); 

62 流程控制的替代语法(天啦，一直以为是模板引擎，太好啦！)

PHP 提供了一些流程控制的替代语法，包括 if，while，for，foreach 和 switch。替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 endif;，endwhile;，endfor;，endforeach; 以及 endswitch;。 
例：if
<?php $variable=2; ?>
<div>
  <?php if($variable==1): ?>      
    <div>One</div>    
  <?php elseif($variable==2): ?>
    </div>Two<div>
  <?php else: ?>
    <div>Others</div>
  <?php endif;?>
</div>

例：while
<?php 
  $arr = ['one','two','three'];
  $i=0;
?>
<ul>
  <?php while($i<3): ?>
    <li><?= $arr[$i] ?></li>
  <?php ++$i; ?>
  <?php endwhile; ?>
</ul>

例：for
<?php $arr = ['one','two','three']; ?>
<ul>
  <?php for($i=0;$i<3;$i++): ?>
    <li><?= $arr[$i] ?></li>  /*注意省略echo 原生直接输出语法*/
  <?php endfor; ?>
</ul>

例：foreach
<?php
  $addressbook = ['neo','lydia'];
?>
<ul>
<?php foreach ($addressbook as $name):?>
    <li><?=$name?></li>
<?php endforeach; ?>
</ul>

例：switch
<?php $variable=3; ?>
<div>
  <?php switch($variable): 
      case 1: ?>      /*特别注意这儿第一个case*/
      <div>One</div>    /*一定要switch在同一个<?php ?>下*/
    <?php break;?>

    <?php case 2: ?>
      </div>Two<div>
    <?php break;?>
    <?php default: ?>
      <div>Others</div>
    <?php break;?>
  <?php endswitch;?>
</div>

 
63 password_hash() 哈希算法函数(由于MD5和sha1)
语法：string password_hash ( string $password , integer $algo [, array $options ] )
password 用户的密码。
algo 一个用来在散列密码时指示算法的密码算法常量。
options
一个包含有选项的关联数组。目前支持两个选项：salt，在散列密码时加的盐（干扰字符串），以及cost，用来指明算法递归的层数。这两个值的例子可在 crypt() 页面找到。
例：
$hash = password_hash('password',PASSWORD_BCRYPT,['cost' => 10]);

64 后期静态绑定
自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。
　　准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”(non-forwarding call)的类名。当进行静态方法调用时，该类名即为明确指定的那个(通常在 :: 运算符左侧部分);当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”(forwarding call)指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。
　　对该特性的理解，可以参考下手册中的例子
　　self vs static
　　用一个demo来直接说明self与static的区别。
self示例：
代码如下:
<?php
  class Vehicle {
    protected static $name = 'This is a Vehicle';

    public static function what_vehicle() {
      echo get_called_class()."<br/>";
      echo self::$name;
    }
  }
  class Sedan extends Vehicle {
    protected static $name = 'This is a Sedan';
  }
  Sedan::what_vehicle();
输出：
Sedan
This is a Vehicle

static示例：
代码如下:
<?php
  class Vehicle {
    protected static $name = 'This is a Vehicle';

    public static function what_vehicle() {
      echo get_called_class()."<br/>";
      echo static::$name;
    }
  }
  class Sedan extends Vehicle {
    protected static $name = 'This is a Sedan';
  }
  Sedan::what_vehicle();
输出：
SedannThis is a Sedan

65 SPL （Standard PHP Library）
函数简单说明：
spl_autoload_register()     注册__autoload()函数
bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] ) 
说明：将函数注册到SPL __autoload函数栈中。如果该栈中的函数尚未激活，则激活它们。 
如果在你的程序中已经实现了__autoload函数，它必须显式注册到__autoload栈中。因为 
spl_autoload_register()函数会将Zend Engine中的__autoload函数取代为spl_autoload()或 
spl_autoload_call()。 
说明2：在spl_autoload_register()没有注册过自定义加载函数，并且使用该函数是也没有
实参，则自动调用时用spl_autoload()，反之则使用spl_autoload_call()，但主要其实spl_autoload()和spl_autoload_call()并不用显示写出代码，因为
use className;new className();这些代码会触发调用自动加载函数；


spl_autoload_unregister()   注销已注册__autoload()函数
bool spl_autoload_unregister ( mixed $autoload_function )

spl_autoload_functions()    返回已注册的__autoload()函数
array spl_autoload_functions ( void )

spl_autoload_extensions()   注册并返回spl_autoload函数使用的默认文件扩展名
string spl_autoload_extensions ([ string $file_extensions ] )

spl_autoload()              __autoload()函数的默认实现(即spl_autoload()相当于实现了__autoload()函数体的函数，如 例1)
void spl_autoload ( string $class_name [, string $file_extensions = spl_autoload_extensions() ] )

spl_autoload_call()         尝试调用所有已注册的__autoload()来装载请求类
void spl_autoload_call ( string $class_name )

说明：spl_autoload 是_autoload()的默认实现，它会去include_path中寻找$class_name(.php/.inc)
说明2：
set_include_path()    设置类似环境变量中的目录;
get_include_path()    获取类似环境变量中的目录；
例：
set_include_path('.' .PATH_SEPARATOR.'../library/' 
.PATH_SEPARATOR.'./application/models/' 
.PATH_SEPARATOR.'./application/lib/' 
.PATH_SEPARATOR.get_include_path()); 
PATH_SEPARATOR是一个常量（路径分隔符），在Linux系统中是一个" : "号,Windows上是一个";"号。

例1：下面的例子功能大致和spl_autoload()一致；
function __autoload($classname){ 
  $classpath=”./”.strtolower($classname).'.php'; 
  if(file_exists($classpath)){ 
    require_once($classpath); 
  } 
  else{ 
    echo ‘class file'.$classpath.'not found!'; 
  } 
} 

例2：child.php
<?php

function registerClass($classname)
{
  include './class/'.$classname.'.php';
}

spl_autoload_register('registerClass');
/*function __autoload($classname)
{
  include './'.$classname.'.php';
}*/

parents::say();     //就可以自动加载，并不需要使用spl_autoload_call();猜测：自动加载是加载整个文件，而不是简单加载类；

文件：/class/parents.php
<?php

class parents 
{
  
  public static function say()
  {
    echo "this is parent!";
  }
}

例3：
spl_autoload_register(function($class){
    if($class == 'http'){
        require_once("/home/yejianfeng/handcode/http.php");
    }
    if($class == 'http2'){
        require_once("/home/yejianfeng/handcode/http2.php");
    }
});

例4：
<?php    
class autoloader {    
    public static $loader;    
        
    public static function init() {    
        if (self::$loader == NULL)    
            self::$loader = new self ();    
            
        return self::$loader;    
    }    
        
    public function __construct() {    
        spl_autoload_register ( array ($this, 'model' ) );    
        spl_autoload_register ( array ($this, 'helper' ) );    
        spl_autoload_register ( array ($this, 'controller' ) );    
        spl_autoload_register ( array ($this, 'library' ) );    
    }    
        
    public function library($class) {    
        set_include_path ( get_include_path () . PATH_SEPARATOR . '/lib/' );    
        spl_autoload_extensions ( '.library.php' );    
        spl_autoload ( $class );    
    }    
        
    public function controller($class) {    
        $class = preg_replace ( '/_controller$/ui', '', $class );    
            
        set_include_path ( get_include_path () . PATH_SEPARATOR . '/controller/' );    
        spl_autoload_extensions ( '.controller.php' );    
        spl_autoload ( $class );    
    }    
        
    public function model($class) {    
        $class = preg_replace ( '/_model$/ui', '', $class );    
            
        set_include_path ( get_include_path () . PATH_SEPARATOR . '/model/' );    
        spl_autoload_extensions ( '.model.php' );    
        spl_autoload ( $class );    
    }    
        
    public function helper($class) {    
        $class = preg_replace ( '/_helper$/ui', '', $class );    
            
        set_include_path ( get_include_path () . PATH_SEPARATOR . '/helper/' );    
        spl_autoload_extensions ( '.helper.php' );    
        spl_autoload ( $class );    
    }    
   
}    
   
//call    
autoloader::init ();    
?>  

例5：综合命名空间的PSR-4规范自动加载类；  
 /**说明：
 *PSR-0面向对象开法规范，是PHP业界的一个规范
 *全部使用命名空间
 *所有PHP文件必须自动载入，不能有require/include
 *单一入口
 *PSR-4 在PSR-0基础上，规范了自动加载的路径问题
 */
<?php
namespace core;
class AutoLoad
{
    /**
     * 维护一个命名空间前缀和具体路径对应的映射表
     * 一个命名空间前缀中可以有多个路径
     *
     * @var array
     */
    protected $prefixes = array();

    /**
     * 注册加载函数到自动加载函数栈中
     * 
     * @return void
     */
    public function register()
    {
        spl_autoload_register(array($this, 'loadClass'));
    }

    /**
     * 给一个命名空间前缀中添加具体的路径.
     *
     * @param string $prefix 命名空间前缀
     * @param string $base_dir 要添加到命名空间中的路径
     * @param bool $prepend 如果为true，则将该路径添加到命名空间对应数组的
     * 最前面，而不是添加到末尾；这个会影响自动加载的搜索文件
     * 
     * @return void
     */
    public function addNamespace($prefix, $base_dir, $prepend = false)
    {
        // 正规化命名空间前缀
        $prefix = trim($prefix, '\\') . '\\';
        
        // 正规化命名空间对应的目录
        $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . '/';
        // 初始化命名空间中该前缀的数组，即如:Foo\var\ 和Foo\var\test\ 在$this->prefixes数组中算两个完全不同的下标，即$this->prefixes['Foo\var\']和$this->prefixes['Foo\var\test\']
        if (isset($this->prefixes[$prefix]) === false) {
            $this->prefixes[$prefix] = array();
        }
        
        // 将目录添加到命名空间数组中$prefix前缀数组中
        if ($prepend) {
            array_unshift($this->prefixes[$prefix], $base_dir);
        } else {
            array_push($this->prefixes[$prefix], $base_dir);
        }
    }

    /**
     * 加载给定类的对应的类库文件
     *
     * @param string $class 完整的类库名称.
     * @return mixed 成功时返回类名对应的类库文件路径，失败时返回false.
     */
    public function loadClass($class)
    {
        // $prefix是当前的命名空间前缀，但开始这里是赋值类全名(包含命名空间)给它，以便进行分割
        $prefix = $class;
        
        //通过命名空间去查找对应的文件，这里php并没有完全遵循运算符优先级规则，先运算后面的赋值运算，然后再进行的判断；
        while (false !== $pos = strrpos($prefix, '\\')) {
            
            // 可能存在的命名空间前缀
            $prefix = substr($class, 0, $pos + 1);
            // 剩余部分是可能存在的类
            $relative_class = substr($class, $pos + 1);
            //试图加载prefix前缀和relitive class对应的文件
            $mapped_file = $this->loadMappedFile($prefix, $relative_class);
            if ($mapped_file) {
                return $mapped_file;
            }
            // 移动命名空间和relative class分割位置到下一个位置
            $prefix = rtrim($prefix, '\\');   
        }
        
        // 未找到试图加载的文件
        return false;
    }
    
    /**
     * 加载命名空间前缀和relative class映射的文件.
     * 
     * @param string $prefix 命名空间前缀.
     * @param string $relative_class relative class名称.
     * @return mixed 成功返回映射的文件路径，失败返回false.
     */
    protected function loadMappedFile($prefix, $relative_class)
    {
        // 命名空间前缀数组中不存在prefix命名空间前缀，返回false.
        if (isset($this->prefixes[$prefix]) === false) {
            return false;
        }
            
        // look through base directories for this namespace prefix
        // 遍历命名空间前缀对应的目录数组，知道找到映射的文件
        foreach ($this->prefixes[$prefix] as $base_dir) {
            // 用具体路径替换掉命名空间前缀,
            // 替换relative class中的命名空间分隔符为目录分隔符
            // 添加.php后缀
            $file = $base_dir
                  . str_replace('\\', DIRECTORY_SEPARATOR, $relative_class)
                  . '.php';
            // 如果映射文件存在加载对应的文件
            if ($this->requireFile($file)) {
            // 返回成功加载的文件路径
                return $file;
            }
        }
        
        // 未找到要映射的文件返回false
        return false;
    }
    
    /**
     * 如果文件存在，从文件系统中加载他到运行环境中.
     * 
     * @param string $file 要加在的文件.
     * @return bool 文件存在返回true，否在返回false.
     */
    protected function requireFile($file)
    {
        if (file_exists($file)) {
            require $file;
            return true;
        }
        return false;
    }
}

备注：loadClass()方法说明：为什么这里要循环着去试图查找文件，在while循环中，会慢慢的缩短命名空间前缀的名称去需找合适的命名空间前缀，为什么要这么做呢？

　　循环查找文件是为了在命名空间中包含更多的内容，不用每次在父命名空间中新建一个文件夹的时候都去添加一个新的命名空间前缀，就像下面描述的一样：
  当前命名空间数组
  {
    'vendor\test1'=>'d:\app\vendor\test1',
  }
  new vendor\test1\hello();//自动加载d:\app\vendor\test1\hello.php文件

  new vendor\test1\child\hello();//首先去查找有没有命名空间前缀[vendor\test1\child],发现没有，再去查找命名空间前缀[vendor\test1],发现存在，于是试图加载d:\app\vendor\test1\child\hello.php,加载成功；  

  当一个文件在一个命名空间下的子目录下的时候，我们不用去新建命名空间前缀就可以成功加载需
要的文件，维护命名空间前缀的数组内容更少，更好维护。

66 debug_backtrace 返回一个回溯追踪数组，即哪个函数或方法调用这个debug_backtrace()的，然后不断递归回到最开始调用代码处，返回的是所有调用信息数组；
语法：array debug_backtrace ([ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0 ]] )
参数可选项：DEBUG_BACKTRACE_PROVIDE_OBJECT 为默认参数会返回调用函数的参数信息；
参数可选项：DEBUG_BACKTRACE_IGNORE_ARGS 与上面对应，则忽略函数参数信息；
A处代码(多数为函数或方法，下同)执行，会调用B函数或方法，B执行，会调用C函数或方法，
在C中var_dump(debug_backtrace());会打印出C处信息，B处信息，A处信息；
信息：包括
file      代码调用处所在文件
line      代码调用处所在文件行号
function  触发调用函数，例：A函数直接调用C，则显示A函数名
class     function方法所属的类名
object    当前对象(没搞懂)
type      调用类型，实例调用返回'->'，类方法调用返回'::'，函数调用什么也不返回
args      如果里面有一个函数，这个函数的参数。如果里面包含了文件，这将列出包含
          文件名（的）。

例：
<?php
  function one($str1, $str2)
   {
   two("Glenn", "Quagmire");
   }
  function two($str1, $str2)
   {
   three("Cleveland", "Brown");
   }
  function three($str1, $str2)
   {
   var_dump(debug_backtrace());
   }
  one("Peter", "Griffin");
结果：（如果采用DEBUG_BACKTRACE_IGNORE_ARGS 参数可选项，则没有args项）
array (size=3)
  0 => 
    array (size=4)
      'file' => string 'E:\wamp\www\test.php' (length=20)
      'line' => int 8
      'function' => string 'three' (length=5)
      'args' => 
        array (size=2)
          0 => &string 'Cleveland' (length=9)
          1 => &string 'Brown' (length=5)
  1 => 
    array (size=4)
      'file' => string 'E:\wamp\www\test.php' (length=20)
      'line' => int 4
      'function' => string 'two' (length=3)
      'args' => 
        array (size=2)
          0 => &string 'Glenn' (length=5)
          1 => &string 'Quagmire' (length=8)
  2 => 
    array (size=4)
      'file' => string 'E:\wamp\www\test.php' (length=20)
      'line' => int 14
      'function' => string 'one' (length=3)
      'args' => 
        array (size=2)
          0 => &string 'Peter' (length=5)
          1 => &string 'Griffin' (length=7)
31 A  匿名函数:没有名字的函数；
语法：$func=function(){};  $func是对象类型， 特别注意：一定要有后面分号；
例：$var=function(){};
     B 闭包函数：子函数可以使用父函数的局部变量，这种行为叫做闭包；用关键字use()引入父函数局部变量；
例：
function one(){
    $a=10;
    $b=20;
    $var=function($he) use($a,&$b){
              echo $he.$a.$b;
             };
    return $var;
}
$func=one();
$func("hahah");
备注：use($a,&$b)中$a只是父函数局部变量$a的复制，并不是引用，当然&$b就是引用了；
闭包应用情况：保护了父函数中的局部变量（形成了封装），
***让局部变量相对于子函数有全局变量的功能（函数调用完，变量不释放）；
a 闭包外层是个函数；b 闭包内部都有函数；c 闭包会return内部函数；d 闭包内部函数不能有return；e 执行闭包后，闭包内部变量会存在，而闭包内部函数的内部变量不会存在；f 需要用use建立变量的引用关系；
    C 匿名函数可以作为实参，直接被调用；

67 闭包、闭包函数(又称匿名函数)
  闭包是可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个
代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。
  在编程领域我们可以通俗的说：子函数可以使用父函数中的局部变量，这种行为
就叫做闭包。
闭包的语法很简单，需要注意的关键字就只有use，use意思是连接闭包和外界变量。
$a = function() use($b) {
 
}

例1：

$func = function( $param ) {
    echo $param;
};  //这里$func是一个Closure类（闭包类）对象
 $func( 'some string' ); 
 //输出：
//some string

例2：
function getMoneyFunc() {
    $rmb = 1;
    $func = function() use ( &$rmb ) {
        echo $rmb;
        //把$rmb的值加1
        $rmb++;
    };
    return $func;
}

$getMoney = getMoneyFunc();
$getMoney();
$getMoney();
$getMoney();

//输出：
//1
//2
//3
参考资料：
http://www.jb51.net/article/36269.htm
http://www.cnblogs.com/yjf512/archive/2012/10/29/2744702.html

闭包示例：(从父作用域继承变量)
<?php
$message = 'hello';

// 没有 "use"
$example = function () {
    var_dump($message);
};
echo $example();

// 继承 $message
$example = function () use ($message) {
    var_dump($message);
};
echo $example();

// Inherited variable's value is from when the function
// is defined, not when called
// 继承的变量值是在函数被定义的时候的变量值，而不是函数被调用的时候；
$message = 'world';
echo $example();

// Reset message
$message = 'hello';

// Inherit by-reference，当然通过引用变量，变量值就是函数被调用时候的变量值了；
$example = function () use (&$message) {
    var_dump($message);
};
echo $example();

// The changed value in the parent scope
// is reflected inside the function call
$message = 'world';
echo $example();

// Closures can also accept regular arguments
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
 

68 filter系列函数：主要是从不安全来源取数据时，起到一个过滤作用
说明：中间用到的各种过滤类型在http://php.net/manual/zh/book.filter.php中；
A filter_has_var
语法：bool filter_has_var ( int $type , string $variable_name )
功能：检查指定的类型变量中是否真实存在该变量，如：$_GET必须要访问链接中变量才算真实，php代码中赋值的，不返回false
变量类型：INPUT_GET, INPUT_POST, INPUT_COOKIE, INPUT_SERVER, or INPUT_ENV
例：
$_GET['test'] = 1;
echo filter_has_var(INPUT_GET, 'test') ? 'Yes' : 'No';
结果为：'No'，只有在地址中输入：http://localhost/test.php?test=2 //结果才会为'Yes'

B filter_id
语法：int filter_id ( string $filtername )
功能：如果获取成功则返回过滤器id，如果过滤器不存在则返回 FALSE 。用filter_list() - 返回所支持的过滤器列表

C filter_input_array
语法：mixed filter_input_array ( int $type [, mixed $definition [, bool $add_empty = true ]] )
功能：对某个类型的多个值进行过滤
参数
INPUT_GET, INPUT_POST, INPUT_COOKIE, INPUT_SERVER, or INPUT_ENV之一。
definition
一个定义参数的数组。一个有效的键必须是一个包含变量名的string，一个有效的值要么是一个filter type，或者是一个array 指明了过滤器、标示和选项。如果值是一个数组，那么它的有效的键可以是 filter， 用于指明 filter type，flags 用于指明任何想要用于过滤器的标示，或者 options 用于指明任何想要用于过滤器的选项。 参考下面的例子来更好的理解这段说明。
这个参数也可以是一个filter constant的整数。那么数组中的所有变量都会被这个过滤器所过滤。

add_empty
在返回值中添加 NULL 作为不存在的键。

返回值
如果成功的话返回一个所请求的变量的数组，如果失败的话返回 FALSE 。对于数组的值，如果过滤失败则返回 FALSE ，如果variable_name 不存在的话则返回 NULL 。 如果标示 FILTER_NULL_ON_FAILURE 被使用了，那么当变量不存在时返回 FALSE ，当过滤失败时返回 NULL 。
例：http://php.net/manual/zh/function.filter-input-array.php

D filter_input
语法：mixed filter_input ( int $type , string $variable_name [, int $filter = FILTER_DEFAULT [, mixed $options ]] )
功能：通过名称获取特定的外部变量，并且可以通过过滤器处理它
参数详情：http://php.net/manual/zh/function.filter-input.php
例子：
<?php
  $search_html = filter_input(INPUT_GET, 'search', FILTER_SANITIZE_SPECIAL_CHARS);
  $search_url = filter_input(INPUT_GET, 'search', FILTER_SANITIZE_ENCODED);
  echo "You have searched for $search_html.\n";
  echo "<a href='?search=$search_url'>Search again.</a>";
?>

E filter_list
语法：array filter_list ( void )
功能：返回所支持的过滤器列表

F filter_var_array
语法：mixed filter_var_array ( array $data [, mixed $definition [, bool $add_empty = true ]] )
功能：获取多个变量并且过滤它们，注意：这个并不像filter_input_array()一样必须是输入的输入，这个$data可以自己定义
详情：http://php.net/manual/zh/function.filter-var-array.php
<?php
error_reporting(E_ALL | E_STRICT);
$data = array(
    'product_id'    => 'libgd<script>',
    'component'     => '10',
    'versions'      => '2.0.33',
    'testscalar'    => array('2', '23', '10', '12'),
    'testarray'     => '2',
);

$args = array(
    'product_id'   => FILTER_SANITIZE_ENCODED,//除去或编码特殊字符 
    'component'    => array('filter'    => FILTER_VALIDATE_INT,
                            'flags'     => FILTER_FORCE_ARRAY, 
                            'options'   => array('min_range' => 1, 'max_range' => 10)
                           ),
    'versions'     => FILTER_SANITIZE_ENCODED,
    'doesnotexist' => FILTER_VALIDATE_INT,
    'testscalar'   => array(
                            'filter' => FILTER_VALIDATE_INT,
                            'flags'  => FILTER_REQUIRE_SCALAR,
                           ),
    'testarray'    => array(
                            'filter' => FILTER_VALIDATE_INT,
                            'flags'  => FILTER_FORCE_ARRAY,
                           )

);

$myinputs = filter_var_array($data, $args);

var_dump($myinputs);
echo "\n";
?>

G filter_var
语法：mixed filter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options ]] )
功能： 使用特定的过滤器过滤一个变量
例：
<?php
var_dump(filter_var('bob@example.com', FILTER_VALIDATE_EMAIL));
var_dump(filter_var('http://example.com', FILTER_VALIDATE_URL, FILTER_FLAG_PATH_REQUIRED));
?>


********************缓存板块***********************

69 全页面静态化缓存
说明：静态化注意和页面缓存分开，虽然都是缓存，但静态化后已经是纯html页面，浏览器可以直接访问该页面，而页面缓存则还是访问php，由php来包含缓存的页面

A 动态页面执行过程：
PHP执行代码会经过如下4个步骤(确切的来说，应该是PHP的语言引擎Zend)
a.Scanning(Lexing) ,将PHP代码转换为语言片段(Tokens)
b.Parsing, 将Tokens转换成简单而有意义的表达式
c.Compilation, 将表达式编译成Opocdes
d.Execution, 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能。

B 静态页面执行过程:并不需要编译，直接执行(浏览器都可以执行html)

C 动态脚本静态化实质就是生成HTML静态文件；
说明：不适合内容经常改变的页面

D PHP静态化分类：
a 纯静态 ：局部纯静态、全部纯静态
b 伪静态

E buffer概述：其实就是缓冲区，内存中用来存储数据的区域，在php执行结束时，自动输出缓冲区内容
输出流程：待输出内容 -> php buffer -> tcp -> 终端
备注：开启buffer两种方式:
第一种：在php配置文件中 ; output_buffering 去掉行首分号
第二种：使用php函数 ob_start()

F 实现页面纯静态化
基本方式：
a file_put_contents()    将内容写入文件，如果文件不存在，则创建；
b 使用php内置缓存机制，利用Output Control 系列函数实现
ob_start()            打开输出缓冲区
ob_get_contents()     返回输出缓冲区内容
ob_clean()            清空缓冲区
ob_get_clean()        得到当前缓冲区的内容并删除当前缓冲区
猜测：缓冲区是php设置的，应该针对每个用户来说的，用户与用户之间的缓冲区不交叉；
部分函数：
ob_start()          打开输出控制缓冲
ob_get_contents()   返回缓冲区的内容
ob_clean()          清空输出缓冲区
ob_get_clean()      得到当前缓冲区的内容并删除当前输出缓冲。 
备注：函数命中涉及`flush`一般表示输出缓冲到浏览器，涉及`clean`一般表示清空缓冲区，涉及`end`表示关闭缓冲区
函数详情：http://php.net/manual/zh/ref.outcontrol.php

例：(其实这个算页面缓存，并不是静态化，不过他们俩原理一样)
<?php
  //判断是否存在缓存文件，有则直接调用缓存文件
  if (is_file('./runtime/index.html') && ($_SERVER['REQUEST_TIME'] < filemtime('./runtime/index.html') + 300)) {
    require_once './runtime/index.html';
  } else {
    $arr = [
      ['name' => 'neo', 'age' => 18],
      ['name' => 'lydia', 'age' => 25],
      ['name' => 'hehe', 'age' => 30],
    ];//代表获取的数据(从数据库、内存以及文件等获取的数据)
    echo "现在是没有采取缓存的页面<br/>";//标记不是缓存页面
    ob_start();
    require_once('./template/temp_one.php');//获取模板文件
    file_put_contents('./runtime/index.html',ob_get_contents());
  }
详情：参考  学习实例/页面静态化/

G 局部动态化：在纯静态的页面中需要改变部分内容；
需求：网站首页，静态化后，但是必须要动态显示用户登录信息，还有即时显示各种数据等；
原理：在静态化页面内容中，利用ajax技术；静态页面先到达客户端，再执行ajax，获取动态内容；

H 伪静态的实现

a 第一种方式：
  一、利用$_SERVER['PATH_INFO'];特别注意localhost/index.php
是不会有这个值的，url必须是pathinfo形式才行,如：localhost/index.php/test.html

  二、将得到的pathinfo值，进行正则表达式匹配，然后如大多数框架类似的去调用各种控制器类文件，执行相应操作;

b 第二种方式
Apache下(Nginx有所不同)  
  一、配置虚拟域名(本质就是本地的localhost别名而已),参考：
http://jingyan.baidu.com/article/358570f6660fbbce4624fc74.html
  二、在E:\wamp\bin\apache\apache2.4.9\conf\extra\httpd-vhosts.conf增加下面代码
<VirtualHost *:80>
    DocumentRoot "e:\wamp\www"
        ServerName fiveinch.com

    <Directory "e:\wamp\www">
        Options Indexes FollowSymLinks
        Order allow,deny
        Allow from all
    </Directory>

    RewriteEngine on
    # If a directory or a file exists, use the request directly
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-f  #表示如果存在该文件，优先采用文件
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-d  #表示如果存在该目录，优先采用目录
    # Otherwise forward the request to index.php
    RewriteRule ^/detail/([0-9]*).html$ /detail.php?id=$1  #伪静态规则，感觉类似于.htaccess
</VirtualHost>




70 页面缓存
原理：跟页面静态化一样，不过本质是访问php，又php代码判断是否执行缓存；

备注：页面缓存中的动态内容，跟yii2采用的方式一样，首先在模板中做好标记，然后利用strtr()函数替换缓存页面中的内容；

71 分页缓存(备注：这个不是技术，而是一种想要的效果，下面操作只是猜测，未验证)
说明：缓存本身是针对变化不大的数据进行的，现在要针对搜索分页做缓存
步骤：
一、建立搜索关键词表，用户搜索一次，在表中记录搜索次数字段增加一次，为了防止这个关键词表过大，可以定期(当然表中还得有个时间戳字段)删除次数较少的记录；

二、把超过一定搜索次数的关键字的搜索结果(规定前多少条记录，如300条)序列化为文件进行缓存

搜索关键字表
CREATE TABLE `search_key` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '关键字id',
  `keys` varchar(40)  NOT NULL DEFAULT '' COMMENT '关键字内容',
  `odd_count` int(11) unsigned NOT NULL DEFAULT 0 COMMENT '单月搜索次數',
  `even_count` int(11) unsigned NOT NULL DEFAULT 0 COMMENT '双月搜索次數',
  `absolute` int(3) unsigned NOT NULL DEFAULT 0 COMMENT '表示绝对缓存，不管搜索次数',
  `cache` int(1) unsigned NOT NULL DEFAULT 0 COMMENT '是否已缓存',
  `goods_count` int(11) unsigned NOT NULL DEFAULT 0 COMMENT '搜索结果的产品总数',
  
  PRIMARY KEY (`id`),
  KEY `keys` (`keys`)
) ENGINE=InnoDB CHARSET=utf8;
备注：上月搜索次数，作为这个月缓存的标准(排名前多少的做缓存)，这个月的搜索次数进入该月累计；下一个月采用这个月的统计次数做缓存依据，上一个月的清空，开始统计；


72 OPcache缓存：利用php的字节码存储到内存来做缓存；
字节码缓存参考：
http://www.laruence.com/2008/06/18/221.html
http://www.laruence.com/2013/11/11/2928.html
具体实现参考：/OPcache缓存


*************************PHP 安全篇*****************************************

73 跨站脚本攻击(即 XSS)：主要是后台没有对用户输入进行实体化，用户恶意提交含有js代码的内容，当其他用户正常访问网站时，这些js代码传递给了正常用户页面，获取到了用户信息；

简单防御：
1）为Cookie设置HttpOnly属性，浏览器将禁止页面的Javascript访问带有HttpOnly属性的Cookie。目前主流浏览器都支持，HttpOnly解决是XSS后的Cookie支持攻击。
例：
<?php  
header("Set-Cookie: cookie1=test1;");  
header("Set-Cookie: cookie2=test2;httponly",false);  //设置了HttpOnly属性
  
setcookie('cookie3','test3',NULL,NULL,NULL,NULL,false);  
setcookie('cookie4','test4',NULL,NULL,NULL,NULL,true);  //设置了HttpOnly属性
?>  
<script>  
    alert(document.cookie);  
</script> 

2）对用户输入信息进行实体化，如利用htmlspecialchars(),当然也可以采用htmlentities()，并且输出已进行一次实体化操作;


74 跨站请求伪造(即 CSRF)：用户登录正常网站，但未退出，点击其他非法网站，非法网站有对用户不利的请求连接(如：转走用户金钱)，由于用户已经登录，所以不利请求链接会携带正常网站登录的cookie信息去操作正常网站，服务端以为是用户正常操作，从而造成危害；

简单防范：在页面表单中和任何正常提交的数据中包含伪随机数项(即token)，服务器对于提交数据先验证token；另一种方式是使用验证码；

75 sql注入：提交信息中含有sql语句，后台没有进行过滤，直接拼接成sql语句，造成对服务器数据的危害；

简单防范：使用PDO的参数绑定和预编译；


补充：Dos攻击
DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果

参考资料：http://baike.baidu.com/link?url=NXPmFInvaXtQCF6xPYKdjnr7FzAnfLFEAaoLofJaIFEgG7Wyr7skGE7oz2ISqoJ5kbtwByWtXqjWKoTymjBW5K



76 
PSR-0

vendor/
  vendor_name/
    package_name/
      src/
        Vendor_Name/
          Package_Name/
            ClassName.php    # Vendor_Name\Package_Name\ClassName
      tests/
        Vendor_Name/
          Package_Name/
            ClassNameTest.php   # Vendor_Name\Package_Name\ClassNameTest


PSR-4

vendor/
  vendor_name/
    package_name/
      src/
        ClassName.php    # Vendor_Name\Package_Name\ClassName
      tests/
        ClassNameTest.php   # Vendor_Name\Package_Name\ClassNameTest
        
更多区别：http://www.tuicool.com/articles/JZzmeqq


110 PHP原生函数
A   mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] )
第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。

B   mixed call_user_func_array ( callable $callback , array $param_arr )
把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入，得是索引数组。
例：
Note:
请注意，传入call_user_func()的参数不能为引用传递。
<?php
error_reporting(E_ALL);
function increment(&$var)
{
    $var++;
}

$a = 0;
call_user_func('increment', $a);
echo $a."\n";

call_user_func_array('increment', array(&$a)); // You can use this instead before PHP 5.3
echo $a."\n";





111 暂无归类
PHP_EOL

filemtime()获取文件上次修改时间
fileatime()获取文件上次访问时间
filectime()取得文件的 inode 修改时间
备注：上述三个函数对文件夹同样有效；

额外知识：操作php配置文件函数
ini_get()获取配置参数，例：echo ini_get('display_errors'); 
ini_set()设置配置参数，例：ini_set('display_errors',0);
ini_get_all()获取所有配置信息，例：print_r(ini_get_all());
ini_restore()恢复配置信息到原始值，例：ini_restore('display_errors');

*********************php 简易知识****************************************

112 在php代码中，类和函数在代码中位置无先后之分，即类或者函数的声明在类和函数使用的后面也是可以的，例：
<?php
  $obj = new test();

  echo $obj->name;
  calu();
  
  class test 
  {
    public $name='neo';
  }

   function calu($value='')
  {
    echo "1111";
  }
备注：正常执行；

113 调用php类的静态方法时，类不会先执行类的__construct()哦！

124 转义符\，在单引号或者双引号中，再能转义(是指转义符配合后面的字符是否具有其他作用)的情况下，都会转义，当然单引号中只转转义符本身和单引号；

125 self和static关键字说明
class A {

  static public $name='parent';
  public static function get_self() {
    echo self::$name;
    return new self();//返回该类实例对象
  }
 
  public static function get_static() {
    echo static::$name;
    return new static();//后期绑定类(即继承类)实例对象
  }
}
 
class B extends A {
  public static $name='child';
}
 
echo get_class(B::get_self()); // parentA
echo get_class(B::get_static()); // childB
echo get_class(A::get_static()); // parentA
说明：self代替的类时self这几个字符所在的类，有点类似于魔术变量__CLASS__之类的；
static代表用到static的类，即后面的继承类用到，则代表继承类；

126 写递归函数，先写最简单情况下的递归出口；

127 apache重写规则
RewriteEngine on
# If a directory or a file exists, use the request directly
RewriteCond %{REQUEST_FILENAME} !-f
#RewriteCond %{REQUEST_FILENAME} !-d #注意：如果打开这句，表示如果浏览器访问路径存在，则显示路径中的所有文件，最好删除，删除后，该与.htaccess文件的同级目录以及目录的递归子目录，在访问时都将不会再显示文件；
# Otherwise forward the request to index.php
RewriteRule . index.php   #这里是缺省，则自动访问index.php

说明：
A 目录中没有.htaccess文件，则浏览器既可以访问目录也可以访问文件；
B 目录中有.htaccess文件，备注：下面所说的 同级目录及子目录 就是该文件所在目录及其子目录
a 文件中有RewriteCond %{REQUEST_FILENAME} !-f 表示可以访问 同级目录及其子目录中的文件；反之，如果注释了这一行，或者说没有这一行，则无论是通过浏览器地址栏还是html标签中的src=''等属性都无法访问各种类型文件；

b 文件中有RewriteCond %{REQUEST_FILENAME} !-d 表示可以访问 同级目录及其子目录中的目录；反之，如果注释了这一行，或者说没有这一行，则无法访问同级目录的子目录（注意：这儿同级目录还是可以访问）；

c 目录X 包含目录 Y，即X/Y，两个目录中都有.htaccess，目录和文件的访问取决于最近作用的.htaccess，目录的最近作用.htaccess的文件位置是上一级目录中的.htaccess，而不是同级的，文件的最近作用.htaccess是同级下的.htaccess；

d 无论是浏览器地址栏，还是html标签中src属性中的地址(如：<script src="http://localhost/web/asset/jquery.js" ></script>)，如果路径的某个目录中有.htaccess，并且有重写规则，即
RewriteRule . index.php ，则在找不到文件时，都会执行重写规则，即执行目录中的index.php文件（即照样解析php，执行一系列操作）。
判断是否是重定向访问的index.php，根据$_SERVER['REDIRECT_URL']是否有值判断。有，则为重定向，注意：访问http://localhost/web ，web目录中有index.php，这个不算重定向，即$_SERVER['REDIRECT_URL']没有值。



128 php中类名、方法名、函数名都可以用变量来代替；
例：
$obj = new $className();
$obj->$funcName();


129 
A.domain表示的是cookie所在的域，默认为请求的地址，如网址为www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。 

B.path表示cookie所在的目录，asp.net默认为/，就是根目录。在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。
例：真实原理是浏览器会发送相应cookie到服务器
访问http://www.test.com/artical/show/abc/index.php
现在有
cookie1   路径为   /artical
cookie2   路径为   /artical/show
cookie3   路径为   /artical/image

浏览器会将前两个cookie都发送到服务器端，即index.php页面两个cookie都可以用；
但是cookie3则不会发送，因为cookie路径无法与访问链接中的路径匹配，即在链接中找到路径；

备注：如果cookie1中有一个键为'name'的元素,cookie2中也有一个键'name'的元素，如果访问/artical中页面就采用cookie1的，如果访问/artical/show中的页面就用/artical/show的cookie中的的值，如果/artical/show的cookie没有该键值，则用/artical的cookie中的值；

C.浏览器会将domain和path都相同的cookie保存在一个文件里(也就是说domain相同，path不同都不会保存在同一个文件中)，cookie间用*隔开。

备注：
cookie简要说明
a 如下代码：
setcookie('name','haha');
setcookie('name','haha',0,'/test');
setcookie('age','1');
说明：会形成3个cookie文件，在firebug中名称一列分别是'name','name','age'，前两者在路径一列会有不同；

session简要说明
A session_name() 读取/设置会话名称
a 读取会话名称，名称默认是PHPSESSIONID，设置名称(执行session_name('这里设置session名字'))后，要再执行session_name()才能返回设置的名称；
即返回的是已经正在使用的session_name,不会返回session_name()中的实参。即上一个session_name

b 设置名称要在session_start()之前(在之后设置的话，名字虽然会改变，但猜测：实际还是同一个session，因为可以取值了)，并且设置名称后，
之后代码中的$_SESSION只会自动取这个名称中的session值，该名称session中没有要取的值
则返回空，即使其他名称的session中值，也不会取；

B session_save_path()返回session存储位置；

130 接管错误处理

<?php
namespace fi\base;

/**
* 错误接管类
*/
class ErrorHandler extends Component
{
  //调试等级，在非测试环境起作用
  protected $levels = [
    E_ERROR,
    E_WARNING,
    E_PARSE,
    E_CORE_ERROR,
    E_COMPILE_ERROR,
    E_USER_ERROR
  ];
  public function register()
  {
    //禁止错误输出
    ini_set("display_errors", "off" );
    //设置异常处理器
    set_exception_handler([$this,'exceptionHandler']);
    //设置错误处理器
    set_error_handler([$this,'errorHandler']);
    //设置致命错误处理器
    register_shutdown_function([$this,'fatalErrorHandler']);
  }
  /**
   * 异常处理器
   * @param  object $e 异常类Exception对象
   * @return [type]    [description]
   */
  public function exceptionHandler($e)
  {

    $this->errorHandler($e->getCode(),$e->getMessage(),$e->getFile(),$e->getLine());
  }
  /**
   * 错误处理器
   * @param  [type] $errno   错误代码
   * @param  [type] $errstr  错误消息
   * @param  [type] $errfile 错误文件
   * @param  [type] $errline 错误行号
   * @return [type]          [description]
   */
  public function errorHandler($errno,$errstr,$errfile,$errline){
    
      $arr = array(
          '['.date('Y-m-d h:i:s').'] ',
          '错误消息：'.$errstr,//有追踪信息
          '错误文件：'.$errfile,
          '文件位置：'.$errline.' 行。',
      );
      //写入错误日志
      //格式 ：  时间 uri | 错误消息 文件位置 第几行
       // error_log(implode(' ',$arr)."\r\n",3,'./test.txt','extra');
      $log_info = implode(' ',$arr)."\r\n";
       if (Fi_DEBUG) {
        echo $log_info;
       } else {
        //判断是否是设置的等级，是则记录
        if (in_array($errno, $this->levels)) {
          $log_dir = APP_PATH.'/'.\Fi::$app->module.'/runtime';
          if (!file_exists($log_dir)) {
            mkdir($log_dir.'/log',755);
          }
          file_put_contents($log_dir.'/log/log.txt', $log_info,FILE_APPEND | LOCK_EX);
        }
       }
       die;
  }
  
  /**
   * 致命错误处理器
   * @return [type] [description]
   */
  public function fatalErrorHandler(){

           $e = error_get_last();
           switch($e['type']){
              case E_ERROR:
              case E_WARNING:
              case E_PARSE:
              case E_CORE_ERROR:
              case E_COMPILE_ERROR:
              case E_USER_ERROR:
                  $this->errorHandler($e['type'],$e['message'],$e['file'],$e['line']);
                  break;         
          }
  }
}

备注：深入理解一下三个函数
//设置异常处理器
set_exception_handler();
//设置错误处理器
set_error_handler();
//设置致命错误处理器
register_shutdown_function();


131 理解php的异常类

A Exception 所有异常的基类，在php7中Exception是继承于接口Throwable的
Exception {

  /* Properties */
  protected string $message ; #错误消息
  protected int $code ;       #错误代码
  protected string $file ;    #错误文件
  protected int $line ;       #错误行号

  /* Methods */
  public __construct ([ string $message = "" [, int $code = 0 [, Throwable $previous = NULL ]]] )
  final public string getMessage ( void )           #获取异常消息，无形参
  final public Exception getPrevious ( void )       #获取前一个异常
  final public mixed getCode ( void )               #获取异常代号
  final public string getFile ( void )              #获取异常发生文件
  final public int getLine ( void )                 #获取异常发生行号
  final public array getTrace ( void )              #获取异常栈追踪(返回数组)
  final public string getTraceAsString ( void )     #获取异常栈追踪(返回字符串)
  public string __toString ( void )                 #字符串表示异常
  final private void __clone ( void )               #返回void，表示不能克隆Exception

}

B ErrorException 一个 Error Exception

ErrorException extends Exception {

  /* Properties */
  protected int $severity ;     #严重程度

  /* Inherited properties */
  protected string $message ;
  protected int $code ;
  protected string $file ;
  protected int $line ;

  /* Methods */
  public __construct ([ string $message = "" [, int $code = 0 [, int $severity = E_ERROR [, string $filename = __FILE__ [, int $lineno = __LINE__ [, Exception $previous = NULL ]]]]]] )
  final public int getSeverity ( void )

  /* Inherited methods */
  final public string Exception::getMessage ( void )
  final public Exception Exception::getPrevious ( void )
  final public mixed Exception::getCode ( void )
  final public string Exception::getFile ( void )
  final public int Exception::getLine ( void )
  final public array Exception::getTrace ( void )
  final public string Exception::getTraceAsString ( void )
  public string Exception::__toString ( void )
  final private void Exception::__clone ( void )

}

C LogicException 表示程序逻辑中的错误异常。这种类型的异常可以直接定位代码中的错误。

/*理解同上*/
LogicException extends Exception {

  /* Inherited properties */
  protected string $message ;
  protected int $code ;
  protected string $file ;
  protected int $line ;

  /* Inherited methods */
  final public string Exception::getMessage ( void )
  final public Exception Exception::getPrevious ( void )
  final public mixed Exception::getCode ( void )
  final public string Exception::getFile ( void )
  final public int Exception::getLine ( void )
  final public array Exception::getTrace ( void )
  final public string Exception::getTraceAsString ( void )
  public string Exception::__toString ( void )
  final private void Exception::__clone ( void )

}

D BadFunctionCallException  如果一个回调涉及到一个未定义的函数，或者如果一些参数丢失，则抛出异常。

//理解同上
BadFunctionCallException extends LogicException {

  /* Inherited properties */
  protected string $message ;
  protected int $code ;
  protected string $file ;
  protected int $line ;

  /* Inherited methods */
  final public string Exception::getMessage ( void )
  final public Exception Exception::getPrevious ( void )
  final public mixed Exception::getCode ( void )
  final public string Exception::getFile ( void )
  final public int Exception::getLine ( void )
  final public array Exception::getTrace ( void )
  final public string Exception::getTraceAsString ( void )
  public string Exception::__toString ( void )
  final private void Exception::__clone ( void )

}

E BadMethodCallException 如果一个回调引用了一个未定义的方法，或者如果缺少一些参数，则抛出异常

//理解同上
BadMethodCallException extends BadFunctionCallException {

  /* Inherited properties */
  protected string $message ;
  protected int $code ;
  protected string $file ;
  protected int $line ;
  /* Inherited methods */

  final public string Exception::getMessage ( void )
  final public Exception Exception::getPrevious ( void )
  final public mixed Exception::getCode ( void )
  final public string Exception::getFile ( void )
  final public int Exception::getLine ( void )
  final public array Exception::getTrace ( void )
  final public string Exception::getTraceAsString ( void )
  public string Exception::__toString ( void )
  final private void Exception::__clone ( void )

}


F RuntimeException 如果在运行时发生错误，该异常抛出。

//理解同上
RuntimeException extends Exception {

  /* Inherited properties */
  protected string $message ;
  protected int $code ;
  protected string $file ;
  protected int $line ;

  /* Inherited methods */
  final public string Exception::getMessage ( void )
  final public Exception Exception::getPrevious ( void )
  final public mixed Exception::getCode ( void )
  final public string Exception::getFile ( void )
  final public int Exception::getLine ( void )
  final public array Exception::getTrace ( void )
  final public string Exception::getTraceAsString ( void )
  public string Exception::__toString ( void )
  final private void Exception::__clone ( void )

}

G UnexpectedValueException  如果一个值与一组值不匹配，则抛出异常。通常情况下，当一个函数调用另一个函数，并期望返回值是某一类型或值，不包括算术或缓冲区相关的错误时，会发生这种情况。

//理解同上
UnexpectedValueException extends RuntimeException {

  /* Inherited properties */
  protected string $message ;
  protected int $code ;
  protected string $file ;
  protected int $line ;

  /* Inherited methods */
  final public string Exception::getMessage ( void )
  final public Exception Exception::getPrevious ( void )
  final public mixed Exception::getCode ( void )
  final public string Exception::getFile ( void )
  final public int Exception::getLine ( void )
  final public array Exception::getTrace ( void )
  final public string Exception::getTraceAsString ( void )
  public string Exception::__toString ( void )
  final private void Exception::__clone ( void )

}


132 
interface     说明：只能声明抽象方法和类常量，不能声明类变量以及类属性；
类的成员变量  说明：无论继承多少次，只会在内存中存储一份，如果改变子类的该成员变量值，那么父类一样会变化，
                    并且不能用unset()删除，只能设值为NULL；
133
mysql中记录id是从1开始的，但是注意 ：limit 0,10 是从0开始的；

134 __call($method, $args)和call_user_func_array(array(),$args)配合使用，最终执行方法与不存在方法参数的值是一致的
class Person
{

    public function __call($method, $args)
    {
        call_user_func_array(array($this, 'get' . $method),$args);
    }

    public function getUser($name, $age)  #这里能分别被赋值
    {
        var_dump($name);
        var_dump($age);
    }
}
(new Person)->User('chao',26); #赋值两个参数

135 php变量和方法说明
区分大小写：变量名，常量名，类属性名，类常量名，类静态成员属性名，数组以及数组下标下标，对象名;

不区分大小写：函数名，方法名，类名
备注：只要取值的，多区分大小写，只要是操作，一般都不区分

136 php预编译注意项
PDOStatement::bindValue 与 PDOStatement::execute() 不能同时用，因为即使在前者中绑定过的数据，execute()也会要求同时绑定一次，虽然两者同时用不会报语法错误；

bindValue和bindParam区别：
方法 bindParam() 和 bindValue() 非常相似。
唯一的区别就是前者使用一个PHP变量绑定参数，而后者使用一个值。

所以使用bindParam是第二个参数只能用变量名，而不能用变量值，而bindValue至可以使用具体值。

$stm = $pdo->prepare("select * from users where user = :user");
$user = "jack";
//正确
$stm->bindParam(":user",$user);
//错误
//$stm->bindParam(":user","jack");
//正确
$stm->bindValue(":user",$user);
//正确
$stm->bindValue(":user","jack");
另外在存储过程中，bindParam可以绑定为input/output变量，如下面：

$stm = $pdo->prepare("call func(:param1)");
$param1 = "abcd";
$stm->bindParam(":param1",$param1); //正确
$stm->execute();
存储过程执行过后的结果可以直接反应到变量上。

对于那些内存中的大数据块参数，处于性能的考虑，应优先使用前者。


137 PHP上传文件，在thinkphp中上传文件，报mimes不允许的错误。
答：其实是tp中不仅限制了文件后缀名，而且还限制了mimes的格式，这个mimes是指$_FILES中的'type'值，只需要将其设置为允许即可，针对于tp，则在上传配置中设置；

### 138 获取系统根目录(即相对于盘符)
```
$_SERVER['DOCUMENT_ROOT'];
```
 
### 139 获取完整域名
js 
```
top.location.href   顶级窗口的地址
this.location.href  当前窗口的地址
```
php 
```
#测试网址:     http://localhost/blog/testurl.php?id=5

//获取域名或主机地址 
echo $_SERVER['HTTP_HOST']."<br>"; #localhost

//获取网页地址 
echo $_SERVER['PHP_SELF']."<br>"; #/blog/testurl.php

//获取网址参数 
echo $_SERVER["QUERY_STRING"]."<br>"; #id=5

//获取用户代理 
echo $_SERVER['HTTP_REFERER']."<br>"; 

//获取完整的url
echo strtolower(explode('/',$_SERVER['SERVER_PROTOCOL'])[0]).'://' .$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];
echo strtolower(explode('/',$_SERVER['SERVER_PROTOCOL'])[0]).'://' .$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'].'?'.$_SERVER['QUERY_STRING'];
#http://localhost/blog/testurl.php?id=5

//包含端口号的完整url
echo strtolower(explode('/',$_SERVER['SERVER_PROTOCOL'])[0]).'://' .$_SERVER['SERVER_NAME'].':'.$_SERVER["SERVER_PORT"].$_SERVER["REQUEST_URI"]; 
#http://localhost:80/blog/testurl.php?id=5

//只取路径
$url=strtolower(explode('/',$_SERVER['SERVER_PROTOCOL'])[0]).'://' .$_SERVER['SERVER_NAME'].$_SERVER["REQUEST_URI"]; 
echo dirname($url);
#http://localhost/blog
```

138 对象的复制
- 采用 = ，则表示对象是引用，并没有实际复制，这里有点类似于js，两者实际物理地址是一个
- 采用 = clone，则表示真实复制对象，两者变化独立了

139 运行ajax跨域
```
header('Access-Control-Allow-Origin:*');
```

140 命令行执行php
1. 判断是否是命令行：`php_sapi_name() == 'cli'`
2. 命令行执行程序时没有客户端ip的；


********************PHP 常见操作*************************************
501   页面跳转方式
a html标签方式：
<meta http-equiv="Refresh" content ="多少秒后跳转;url=跳转地址"/>
例：
<html>
  <head>
    <meta http-equiv="Refresh" content ="3;url=http://www.youku.com"/>
  </head>
  <body>
    <p>页面跳转</p>
  </body>
</html>

b js方式：
方式一：window.location.href="http://www.baidu.com";//这个在本窗口打开(window.可省略)，如：location.href="http://www.baidu.com;
方式二：  window.open("http://www.baidu.com");//在另外的窗口打开(window.可省略)；

 <script>setTimeout('location="http://www.baidu.com"',5000);</script> 备注：js做跳转，第一个参数一定要背引号包裹，页面可以显示信息，该代码是在html文件中；或者写成：<script>setTimeout(function(){location="http://www.baidu.com"},5000);</script> 
备注：exit()函数功能：执行到这个函数时，脚本结束，即后面的所有代码不会执行，但是它前面的该执行的代码会得到执行，并且如果前面有延迟函数等等也会得到执行（如前面echo输出js函数setTimeout()等）；
例：<script>window.setTimeout("window.location='<?php echo site_url('home/index')?>'",3000);</script>

c header文件头(php)方式：
header('location:http://www.youku.com');
header('location:index.php?c=admin&a=index');用于本网站跳转，可以不使用域名
header('Refresh:5;url=http://www.youku.com');
这个做跳转页面，页面就不能显示任何信息；
在CI中，这样也行：
$url = site_url('goods/comment');
$url = "Refresh:5;url={$url}";
header($url);


d 注意：后台无法直接跳出前台frame框架，要借助js；
例：
$url = '<script>top.location.href="'.site_url().'admin/privilege/login"</script>';
exit($url);


502   代码递归写法
a 先考虑最简单数据，编写
b 设计好递归出口
c 完善递归



503   获取页面完整连接
$url['url'] = 'http://'.$_SERVER['SERVER_NAME'].':'.$_SERVER["SERVER_PORT"].$_SERVER["REQUEST_URI"]; 


504   获取客户端和服务器端IP
/**getenv()是php原生函数
 * 获取客户端IP地址
 * @return string
 */
function get_client_ip() { 
    if(getenv('HTTP_CLIENT_IP')){ 
        $client_ip = getenv('HTTP_CLIENT_IP'); 
    } elseif(getenv('HTTP_X_FORWARDED_FOR')) { 
        $client_ip = getenv('HTTP_X_FORWARDED_FOR'); 
    } elseif(getenv('REMOTE_ADDR')) {
        $client_ip = getenv('REMOTE_ADDR'); 
    } else {
        $client_ip = $_SERVER['REMOTE_ADDR'];
    } 
    return $client_ip; 
}  

/**
* 获取服务器端IP地址
 * @return string
 */
function get_server_ip() { 
    if (isset($_SERVER)) { 
        if($_SERVER['SERVER_ADDR']) {
            $server_ip = $_SERVER['SERVER_ADDR']; 
        } else { 
            $server_ip = $_SERVER['LOCAL_ADDR']; 
        } 
    } else { 
        $server_ip = getenv('SERVER_ADDR');
    } 
    return $server_ip; 
}


504 验证手机号码正则表达式
'/^(((13[0-9]{1})|(14[0-9]{1})|(15[0-9]{1})|(17[0-9]{1})|(18[0-9]{1}))+\d{8})$/'


505 解压zip
$zip = new ZipArchive();
if ($zip->open('unzip/hehe.zip') === true) {
    $zip->extractTo('unzip/');    #解压到目录
    $zip->close();
}


506 urlencode和urldecode
urlencode说明：返回字符串，此字符串中除了 -_. 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，空格则编码为加号（+）。此编码与 WWW 表单 POST 数据的编码方式是一样的，同时与 application/x-www-form-urlencoded 的媒体类型编码方式一样。由于历史原因，此编码在将空格编码为加号（+）方面与 » RFC3896 编码（参见 rawurlencode()）不同。
urldecode说明：与urlencode相反；
<?php
$interest = "arts";
$homepage = "http://www.oschina.net";
$query = "homepage=".urlencode( $homepage );
$query .= "&interest=".urlencode( $interest ); 
echo $query;
备注：urlencode针对返回是var=(这个部分)，并且对于只含有数字、字符、-_.的query没有作用；


507 pack()与unpack()的使用
<?php

$body        = 'abcdefghilksdlfjlsdfjlsdjfiosdjfo'; //模拟包体数据
$body_length = strlen($body); //模拟包体长度，可以用strlen()
$token       = '93279e3308bdbbeed946fc965017f67a'; //模拟安全验证

//模拟包头长度，Na32说明：N是指$body_length采用无符号长整数 (32位, 大端字节序)规则，即用4个字节表示整数
//a32表示$token采用将字符串空白以 NULL 字符填满方式。pack()是将数据转化为二进制
$bin_head = pack("Na32", $body_length, $token);
$bin_body = pack("a*", $body); //模拟包体数据

$bin = $bin_head . $bin_body; //拼接二进制

//解包，必需与pack()对应；
//对Nbody_length/a32token/a*body说明：由于$bin数据打包的第一项类型是N，所以解包类型也是N，后面的body_length
//是解包后返回数组的下标(自定义的)，后面以此类推，$bin第二项数据打包格式是a32，则解包时也是a32，后面a*也一样；
var_dump(unpack('Nbody_length/a32token/a*body', $bin));


## Thinkphp

### Thinkphp的漏洞

#### 1 正式模式下,把变量传入了sql组装，组装后的sql中没有变量
原因：
正式：sql先解析，再连接，这样可以判断是否已经缓存过数据，可能想利用缓存
调试：先连接，再进行sql解析，不需要缓存 
正式下，在解析过程中(Pdo.class.php中escapeString方法)，需要$this->dbType进行判断，而这个属性需要在连接方法connect()中才能被赋值，而正式下，这时还没有建立连接，所以造成了该bug

修复：修改一下文件Pdo.class.php中的escapeString()方法 
```
public function escapeString($str) {
   switch($this->dbType) {  //this is problem
      case 'PGSQL':
      case 'MSSQL':
      case 'SQLSRV':
      case 'MYSQL':
      case 'null':    //这句是新加入的
          return addslashes($str);
      case 'IBASE':                
      case 'SQLITE':
      case 'ORACLE':
      case 'OCI':
          return str_ireplace("'", "''", $str);
  }
}
```
备注：这种修补并不完美，但是能用

508 链接为文件地址，怎么让浏览者直接下载，而不是打开
操作：<a href="a.txt" download></a>

